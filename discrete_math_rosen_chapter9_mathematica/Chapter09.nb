(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 8.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       157,          7]
NotebookDataLength[    311795,       9804]
NotebookOptionsPosition[    259693,       8366]
NotebookOutlinePosition[    281035,       8826]
CellTagsIndexPosition[    280084,       8792]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{

Cell[CellGroupData[{
Cell["Relations", "BookChapterTitle",
 CounterAssignments->{{"ChapterNumber", 9}}],

Cell[CellGroupData[{

Cell["Introduction", "Section"],

Cell[TextData[{
 "In this chapter we will learn how to use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to work with relations. We explain how to represent binary relations using \
sets of ordered pairs, zero-one matrices, and directed graphs. We show how to \
use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to determine whether a relation has various properties using these \
different representations."
}], "Text"],

Cell[TextData[{
 "We also describe how to compute closures of relations. In particular, we \
show how to find the transitive closure of a relation using two different \
algorithms and we compare the time performance of these algorithms. After \
explaining how to use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to work with equivalence relations, we show how to use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to work with partial orderings, to draw Hasse diagrams, and to implement \
topological sorting."
}], "Text"],

Cell[TextData[{
 "Some readers may be familiar with the ",
 StyleBox["Combinatorica",
  FontSlant->"Italic"],
 " package. While this package has much to offer, many of the functions it \
was created to provide are now part of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " proper. In this manual, we tend to avoid use of the ",
 StyleBox["Combinatorica",
  FontSlant->"Italic"],
 " package functions, particularly when there are ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " functions that will suffice."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["9.1 Relations and Their Properties", "Section",
 CellTags->"Section1"],

Cell[TextData[{
 "The first step in understanding and manipulating relations in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " is to determine how to represent them. There are no specific functions in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " designed to handle relations. We will implement relations in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " using the most convenient form for the question at hand. In this chapter, \
we will make use of sets of ordered pairs, zero-one matrices, and directed \
graphs in order to explore relations in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell["Relations as Ordered Pairs", "Subsection",
 CellTags->"Section1a"],

Cell["\<\
First, we will represent relations as lists of ordered pairs. We begin by \
defining a predicate to check that an expression is a relation, i.e., a list \
of pairs. Our reason for defining a predicate is that it gives us a way to \
ensure that when arguments are passed to functions we write, the arguments \
are valid for that function. As an illustration of the utility of this \
approach, consider the function below.\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"posIntQ", "[", "n_", "]"}], ":=", 
  RowBox[{
   RowBox[{"IntegerQ", "[", "n", "]"}], "&&", 
   RowBox[{"n", ">", "0"}]}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"myFactorial", "[", 
   RowBox[{"n_", "?", "posIntQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{"If", "[", 
     RowBox[{
      RowBox[{"n", "\[Equal]", "1"}], ",", "\[IndentingNewLine]", 
      RowBox[{"Return", "[", "1", "]"}], ",", "\[IndentingNewLine]", 
      RowBox[{"Return", "[", 
       RowBox[{"n", "*", 
        RowBox[{"myFactorial", "[", 
         RowBox[{"n", "-", "1"}], "]"}]}], "]"}]}], "\[IndentingNewLine]", 
     "]"}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "In this simple example, we define a predicate ",
 StyleBox["posIntQ", "Input"],
 " that tests input for being both an integer and positive. Then the function \
",
 StyleBox["myFactorial", "Input"],
 " uses the ",
 StyleBox[ButtonBox["PatternTest",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/PatternTest"], "FunctionLink"],
 " (",
 StyleBox["?", "Input"],
 ") structure to declare that the function\[CloseCurlyQuote]s definition is \
only valid for those input that satisfy the requirements of the ",
 StyleBox["posIntQ", "Input"],
 " predicate. Consider the result of attempting to compute the factorial of \
-3:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"myFactorial", "[", 
  RowBox[{"-", "3"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"myFactorial", "[", 
  RowBox[{"-", "3"}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The function does not try to execute, but simply echoes the input, \
indicating that the function was not able to operate on that input. It is \
usually better for a function to not try to compute on invalid input. In the \
case of ",
 StyleBox["myFactorial", "Input"],
 ", omitting the predicate would result in an infinite recursion."
}], "Text"],

Cell[TextData[{
 "We could also deal with the problem of potentially invalid arguments by \
checking the arguments within the body of the function. The ",
 StyleBox[ButtonBox["PatternTest",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/PatternTest"], "FunctionLink"],
 " (",
 StyleBox["?", "Input"],
 ") approach, however, makes it much clearer, by just looking at the \
definition, what the argument\[CloseCurlyQuote]s expectations are."
}], "Text"],

Cell[TextData[{
 "As mentioned, we are going to represent relations as lists of ordered \
pairs. We will define two predicates. First, an ordered pair predicate that \
we'll call ",
 StyleBox["pairQ", "Input"],
 ". And then the relation type, which will be called ",
 StyleBox["relationQ", "Input"],
 ", will be defined to be a list of pairs. We define the pair predicate as \
follows:"
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"pairQ", "[", 
    RowBox[{"{", 
     RowBox[{"_", ",", "_"}], "}"}], "]"}], ":=", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"pairQ", "[", "___", "]"}], ":=", "False"}]}], "Input",
 InitializationCell->True],

Cell[TextData[{
 "The first line of the definition says what a pair is. If ",
 StyleBox["pairQ", "Input"],
 " is passed an argument which is a list containing two elements, then it \
returns ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 ". Those elements can be anything at all, including lists and other \
structures, which allows us to define relations among complex structures. The \
second line of the definition says that if ",
 StyleBox["pairQ", "Input"],
 " is passed any argument at all, or no argument, it should produce ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 ". The ",
 StyleBox[ButtonBox["BlankNullSequence",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BlankNullSequence"], "FunctionLink"],
 " (",
 StyleBox["___", "Input"],
 "), formed from three underscores, matches any expression, comma-separated \
sequence of expressions, or no expression at all. This is different from ",
 StyleBox[ButtonBox["BlankSequence",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BlankSequence"], "FunctionLink"],
 " (",
 StyleBox["__", "Input"],
 "), two underscores, which cannot match an empty argument. "
}], "Text"],

Cell[TextData[{
 "You might think that the second definition overwrites the first, since it \
is more general. In fact, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " keeps both definitions, in the order they are given, and applies the first \
definition that matches. So if you give ",
 StyleBox["pairQ", "Input"],
 " an argument that is in fact a pair, the argument will match the pattern of \
the first definition and return ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"pairQ", "[", 
  RowBox[{"{", 
   RowBox[{"5", ",", "\"\<b\>\""}], "}"}], "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "But for any argument that does not match that pattern, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " will go to the second definition, which matches anything, and output ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"pairQ", "[", "5", "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"pairQ", "[", 
  RowBox[{"{", 
   RowBox[{"5", ",", "6", ",", "7"}], "}"}], "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"pairQ", "[", 
  RowBox[{"2", ",", "3"}], "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"pairQ", "[", "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[TextData[{
 "With ",
 StyleBox["pairQ", "Input"],
 " in place, we define ",
 StyleBox["relationQ", "Input"],
 "."
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"relationQ", "[", 
    RowBox[{"{", 
     RowBox[{"___", "?", "pairQ"}], "}"}], "]"}], ":=", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"relationQ", "[", "___", "]"}], ":=", "False"}]}], "Input",
 InitializationCell->True],

Cell[TextData[{
 "In this case, the first line insists that a relation must be a list \
containing a ",
 StyleBox[ButtonBox["BlankNullSequence",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BlankNullSequence"], "FunctionLink"],
 " (",
 StyleBox["___", "Input"],
 "), i.e., a comma-separated sequence of expressions, each one of which \
satisfies ",
 StyleBox["pairQ", "Input"],
 ". That is, a (binary) relation is a set of ordered pairs."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Creating Relations", "Subsection",
 CellTags->"Section1b"],

Cell["\<\
Now that we\[CloseCurlyQuote]ve established the relation predicate, let\
\[CloseCurlyQuote]s create an actual relation.\
\>", "Text"],

Cell[CellGroupData[{

Cell["The Divides Relation", "Subsubsection"],

Cell[TextData[{
 "Example 4 in Section 9.1 describes the \[OpenCurlyDoubleQuote]divides \
relation,\[CloseCurlyDoubleQuote] i.e., ",
 Cell[BoxData[
  FormBox[
   RowBox[{"R", "=", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"a", ",", "b"}], ")"}], "|", 
      RowBox[{"a", " ", "divides", " ", "b"}]}], "}"}]}], TraditionalForm]]],
 ". We will write a function to construct this relation. The function will \
consider every possible ordered pair of elements and will include them in the \
relation if they satisfy the condition that ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]]],
 " is divisible by ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 ", using the ",
 StyleBox[ButtonBox["Divisible",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Divisible"], "FunctionLink"],
 " function."
}], "Text"],

Cell[TextData[{
 "We use the ",
 StyleBox[ButtonBox["Tuples",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Tuples"], "FunctionLink"],
 " function to generate all possible pairs of a list of elements. It takes \
two arguments: the list of elements is the first argument, and 2 will be the \
second argument to indicate that we desire pairs of elements. For example, \
the following creates all pairs of elements from ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], TraditionalForm]]],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Tuples", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], ",", "2"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "To the output of ",
 StyleBox[ButtonBox["Tuples",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Tuples"], "FunctionLink"],
 ", we apply ",
 StyleBox[ButtonBox["Select",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Select"], "FunctionLink"],
 " to obtain the sublist of elements that satisfy the divisibility condition. \
",
 StyleBox[ButtonBox["Select",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Select"], "FunctionLink"],
 " requires two arguments. The first is the list of elements to select from. \
The second is a function name or a pure ",
 StyleBox[ButtonBox["Function",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Function"], "FunctionLink"],
 " (",
 StyleBox["&", "Input"],
 ") that returns ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 " for the desired elements. We will use a pure ",
 StyleBox[ButtonBox["Function",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Function"], "FunctionLink"],
 " (",
 StyleBox["&", "Input"],
 ") to apply the ",
 StyleBox[ButtonBox["Divisible",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Divisible"], "FunctionLink"],
 " function to the arguments in reverse order."
}], "Text"],

Cell[TextData[{
 "The ",
 StyleBox["dividesRelation", "Input"],
 " function below uses these ideas. Its argument is a list of integers, and \
it produces the relation."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"dividesRelation", "[", 
   RowBox[{"A", ":", 
    RowBox[{"{", "__Integer", "}"}]}], "]"}], ":=", 
  RowBox[{"Select", "[", 
   RowBox[{
    RowBox[{"Tuples", "[", 
     RowBox[{"A", ",", "2"}], "]"}], ",", 
    RowBox[{
     RowBox[{"Divisible", "[", 
      RowBox[{
       RowBox[{"#", "[", 
        RowBox[{"[", "2", "]"}], "]"}], ",", 
       RowBox[{"#", "[", 
        RowBox[{"[", "1", "]"}], "]"}]}], "]"}], "&"}]}], "]"}]}]], "Input",
 InitializationCell->True],

Cell["\<\
We use the function to construct the divides relation on the integers 1 \
through 4.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"dividesRelation", "[", 
  RowBox[{"Range", "[", "4", "]"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "4"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "We can check that this function has produced an expression that satisfies \
",
 StyleBox["relationQ", "Input"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"relationQ", "[", "%", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "For convenience, we can overload the ",
 StyleBox["dividesRelation", "Input"],
 " symbol to also accept a single positive integer ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " as the argument and construct the \[OpenCurlyDoubleQuote]divides relation\
\[CloseCurlyDoubleQuote] on ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "\[Ellipsis]", ",", "n"}], "}"}], 
   TraditionalForm]]],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"dividesRelation", "[", "n_Integer", "]"}], ":=", 
  RowBox[{"Select", "[", 
   RowBox[{
    RowBox[{"Tuples", "[", 
     RowBox[{
      RowBox[{"Range", "[", "n", "]"}], ",", "2"}], "]"}], ",", 
    RowBox[{
     RowBox[{"Divisible", "[", 
      RowBox[{
       RowBox[{"#", "[", 
        RowBox[{"[", "2", "]"}], "]"}], ",", 
       RowBox[{"#", "[", 
        RowBox[{"[", "1", "]"}], "]"}]}], "]"}], "&"}]}], "]"}]}]], "Input",
 InitializationCell->True],

Cell["For example:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"div6", "=", 
  RowBox[{"dividesRelation", "[", "6", "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "6"}], "}"}]}], "}"}]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Inverse of a Relation", "Subsubsection"],

Cell["\<\
Now that we have seen an example of a function that creates a relation, let's \
look at a simple example of a function that manipulates a relation.\
\>", "Text"],

Cell[TextData[{
 "For any relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ", its inverse relation, denoted ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["R", 
    RowBox[{"-", "1"}]], TraditionalForm]]],
 " is defined by ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["R", 
     RowBox[{"-", "1"}]], "=", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"b", ",", "a"}], ")"}], "|", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"a", ",", "b"}], ")"}], "\[Element]", "R"}]}], "}"}]}], 
   TraditionalForm]]],
 ". The following function computes the inverse of a relation."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"inverseRelation", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"Reverse", "[", 
   RowBox[{"R", ",", "2"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["Reverse",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reverse"], "FunctionLink"],
 " function is used to reverse the elements of a list. Given a list as a sole \
argument, ",
 StyleBox[ButtonBox["Reverse",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reverse"], "FunctionLink"],
 " simply inverts the order."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Reverse", "[", 
  RowBox[{"{", 
   RowBox[{"1", ",", "2", ",", "3"}], "}"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"3", ",", "2", ",", "1"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 StyleBox[ButtonBox["Reverse",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reverse"], "FunctionLink"],
 " accepts a second optional argument to specify a level. In this case we use \
2 to indicate that we want ",
 StyleBox[ButtonBox["Reverse",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reverse"], "FunctionLink"],
 " to change the order of the sublists of the relation, not the order of the \
elements of ",
 StyleBox["R", "Input"],
 " itself."
}], "Text"],

Cell[TextData[{
 "Since we\[CloseCurlyQuote]ve defined the \[OpenCurlyDoubleQuote]divides\
\[CloseCurlyDoubleQuote] relation, we can use the ",
 StyleBox["inverseRelation", "Input"],
 " function to create the \[OpenCurlyDoubleQuote]multiple of\
\[CloseCurlyDoubleQuote] relation."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"mul6", "=", 
  RowBox[{"inverseRelation", "[", "div6", "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "6"}], "}"}]}], "}"}]], "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Properties of Relations", "Subsection",
 CellTags->"Section1c"],

Cell[TextData[{
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be used to determine if a relation has a particular property, such as \
reflexivity, symmetry, antisymmetry or transitivity. This can be accomplished \
by creating ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " functions that take as input the given relation, examine the elements of \
the relation, and return ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 " or ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 " based on whether the relation has the property or not."
}], "Text"],

Cell[TextData[{
 "Before writing functions to test for properties of relations, it will be \
convenient to have a routine that extracts the domain of a given relation. \
This function works by applying ",
 StyleBox[ButtonBox["Flatten",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Flatten"], "FunctionLink"],
 " to the relation. Note that it may be the case that the objects in our \
relation are themselves lists, e.g., the subset relation. So we give ",
 StyleBox[ButtonBox["Flatten",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Flatten"], "FunctionLink"],
 " the second argument 1, indicating that it should only flatten the list \
down to the first level. This way, if the pairs in the relation are elements, \
the pairs will be preserved, as shown below."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"subsets3", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", "}"}], ",", 
       RowBox[{"{", "1", "}"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", "}"}], ",", 
       RowBox[{"{", "2", "}"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", "1", "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", "2", "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}]}], "}"}]}], "}"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Flatten", "[", 
  RowBox[{"subsets3", ",", "1"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", "1", "}"}], ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", "2", "}"}], ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", "1", "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", "2", "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "After flattening, we apply ",
 StyleBox[ButtonBox["Union",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Union"], "FunctionLink"],
 " to remove duplicates and put the output in canonical order. "
}], "Text"],

Cell["\<\
Note that, strictly speaking, the result from this function need not equal \
the domain of the relation, since there may exist elements in the domain that \
are not related to any object in the domain. It might be better to call this \
the \"effective domain\" of the relation.\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"findDomain", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"Union", "[", 
   RowBox[{"Flatten", "[", 
    RowBox[{"R", ",", "1"}], "]"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell["\<\
Observe that this gives the expected output for both the \
\[OpenCurlyDoubleQuote]divides\[CloseCurlyDoubleQuote] relation and the \
subsets relation.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"findDomain", "[", "div6", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6"}], 
  "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"findDomain", "[", "subsets3", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", "1", "}"}], ",", 
   RowBox[{"{", "2", "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Reflexivity", "Subsubsection"],

Cell[TextData[{
 "Now we are ready to begin testing relations for various properties. The \
first property we consider is reflexivity. Remember that a relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " is reflexive if ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"a", ",", "a"}], ")"}], "\[Element]", "R"}], TraditionalForm]]],
 " for every ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 " in the domain."
}], "Text"],

Cell[TextData[{
 "To check to see if a relation is reflexive, we compute the domain of the \
relation and then check each element ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 " of the domain to see if ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "a"}], ")"}], TraditionalForm]]],
 " is in the relation. If the function finds an element of the domain with ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"a", ",", "a"}], ")"}], "\[NotElement]", "R"}], 
   TraditionalForm]]],
 ", then it returns ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 " immediately. If it checks all of the members of the domain with no \
failures, then it returns ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"reflexiveQ", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"a", ",", "domain"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"domain", "=", 
      RowBox[{"findDomain", "[", "R", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"Catch", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"Do", "[", 
        RowBox[{
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{"!", 
            RowBox[{"MemberQ", "[", 
             RowBox[{"R", ",", 
              RowBox[{"{", 
               RowBox[{"a", ",", "a"}], "}"}]}], "]"}]}], ",", 
           RowBox[{"Throw", "[", "False", "]"}]}], "]"}], 
         "\[IndentingNewLine]", ",", 
         RowBox[{"{", 
          RowBox[{"a", ",", "domain"}], "}"}]}], "]"}], ";", 
       "\[IndentingNewLine]", 
       RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", 
      "]"}]}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "Recall that the ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " function\[CloseCurlyQuote]s second argument, ",
 StyleBox["{a,domain}", "Input"],
 " specifies that the variable ",
 StyleBox["a", "Input"],
 " is to be assigned to every member of the list ",
 StyleBox["domain", "Input"],
 ". Also recall that ",
 StyleBox[ButtonBox["MemberQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MemberQ"], "FunctionLink"],
 " expects its first argument to be the list and the second argument to be \
the element being sought. "
}], "Text"],

Cell["\<\
We can use this on the \[OpenCurlyDoubleQuote]divides\[CloseCurlyDoubleQuote] \
relation.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"reflexiveQ", "[", "div6", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Symmetry", "Subsubsection"],

Cell[TextData[{
 "Next we will examine the symmetric and antisymmetric properties. To \
determine whether a relation is symmetric, we simply use the definition. That \
is, we check, for every member ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"a", ",", "b"}], ")"}], "\[Element]", "R"}], TraditionalForm]]],
 ", whether ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"b", ",", "a"}], ")"}], TraditionalForm]]],
 " is also a member of the relation. If we discover a pair in the relation \
for which the reverse pair is not in the relation, then we know that the \
relation is not symmetric. Otherwise, it must be symmetric. This is the logic \
employed by the following function."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"symmetricQ", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "u", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{"Catch", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Do", "[", 
       RowBox[{
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{"!", 
           RowBox[{"MemberQ", "[", 
            RowBox[{"R", ",", 
             RowBox[{"Reverse", "[", "u", "]"}]}], "]"}]}], ",", 
          RowBox[{"Throw", "[", "False", "]"}]}], "]"}], 
        "\[IndentingNewLine]", ",", 
        RowBox[{"{", 
         RowBox[{"u", ",", "R"}], "}"}]}], "]"}], ";", "\[IndentingNewLine]", 
      
      RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell["\<\
For example, we can see that the \[OpenCurlyDoubleQuote]divides\
\[CloseCurlyDoubleQuote] relation is not symmetric.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"symmetricQ", "[", "div6", "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell["\<\
The union of \[OpenCurlyDoubleQuote]divides\[CloseCurlyDoubleQuote] and \
\[OpenCurlyDoubleQuote]multiple of\[CloseCurlyDoubleQuote] is symmetric, \
however.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"divOrMul6", "=", 
  RowBox[{"Union", "[", 
   RowBox[{"div6", ",", "mul6"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "6"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"symmetricQ", "[", "divOrMul6", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "To determine whether a given relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " is antisymmetric, we again use the definition. Remember that a relation is \
antisymmetric when it has the property that whenever a pair ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "b"}], ")"}], TraditionalForm]]],
 " and its reverse ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"b", ",", "a"}], ")"}], TraditionalForm]]],
 " both belong to ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ", then it must be that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"a", "=", "b"}], TraditionalForm]]],
 ". To check this, we simply loop over all members ",
 Cell[BoxData[
  FormBox["u", TraditionalForm]]],
 " of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " and see if the opposite pair belongs to ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " and whether the members of the pair are different."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"antisymmetricQ", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "u", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{"Catch", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Do", "[", 
       RowBox[{
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"MemberQ", "[", 
            RowBox[{"R", ",", 
             RowBox[{"Reverse", "[", "u", "]"}]}], "]"}], "&&", 
           RowBox[{
            RowBox[{"u", "[", 
             RowBox[{"[", "1", "]"}], "]"}], "\[NotEqual]", 
            RowBox[{"u", "[", 
             RowBox[{"[", "2", "]"}], "]"}]}]}], ",", 
          RowBox[{"Throw", "[", "False", "]"}]}], "]"}], 
        "\[IndentingNewLine]", ",", 
        RowBox[{"{", 
         RowBox[{"u", ",", "R"}], "}"}]}], "]"}], ";", "\[IndentingNewLine]", 
      
      RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell["\<\
We now use this function to check to see if the \
\[OpenCurlyDoubleQuote]divides\[CloseCurlyDoubleQuote] and \
\[OpenCurlyDoubleQuote]multiple of\[CloseCurlyDoubleQuote] relations defined \
earlier are antisymmetric.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"antisymmetricQ", "[", "div6", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"antisymmetricQ", "[", "mul6", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Transitivity", "Subsubsection"],

Cell[TextData[{
 "The transitive property is the most difficult to check. Recall the \
definition of transitive relations: a relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " is transitive if, whenever ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "b"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"b", ",", "c"}], ")"}], TraditionalForm]]],
 " are in ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ", then ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "c"}], ")"}], TraditionalForm]]],
 " must be as well."
}], "Text"],

Cell[TextData[{
 "To check transitivity, we will consider all possible ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 ", ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]]],
 ", and ",
 Cell[BoxData[
  FormBox["c", TraditionalForm]]],
 " in the domain of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ". Then if ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"a", ",", "b"}], ")"}], "\[Element]", "R"}], TraditionalForm]]],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"b", ",", "c"}], ")"}], "\[Element]", "R"}], TraditionalForm]]],
 ", and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"a", ",", "c"}], ")"}], "\[NotElement]", "R"}], 
   TraditionalForm]]],
 ", we know that the relation is not transitive. If there is no such triple \
",
 Cell[BoxData[
  FormBox[
   RowBox[{"a", ",", "b", ",", "c"}], TraditionalForm]]],
 " to contradict transitivity, then we conclude that the relation is \
transitive."
}], "Text"],

Cell["Here is the function.", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"transitiveQ", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"domain", ",", "a", ",", "b", ",", "c"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"domain", "=", 
      RowBox[{"findDomain", "[", "R", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"Catch", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"Do", "[", 
        RowBox[{
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"MemberQ", "[", 
             RowBox[{"R", ",", 
              RowBox[{"{", 
               RowBox[{"a", ",", "b"}], "}"}]}], "]"}], "&&", 
            RowBox[{"MemberQ", "[", 
             RowBox[{"R", ",", 
              RowBox[{"{", 
               RowBox[{"b", ",", "c"}], "}"}]}], "]"}], "&&", 
            RowBox[{"!", 
             RowBox[{"MemberQ", "[", 
              RowBox[{"R", ",", 
               RowBox[{"{", 
                RowBox[{"a", ",", "c"}], "}"}]}], "]"}]}]}], ",", 
           RowBox[{"Throw", "[", "False", "]"}]}], "]"}], 
         "\[IndentingNewLine]", ",", 
         RowBox[{"{", 
          RowBox[{"a", ",", "domain"}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"b", ",", "domain"}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"c", ",", "domain"}], "}"}]}], "]"}], ";", 
       "\[IndentingNewLine]", 
       RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", 
      "]"}]}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "We see that the \[OpenCurlyDoubleQuote]divisible\[CloseCurlyDoubleQuote] \
relation is transitive. But we can cause it to fail to be transitive by \
removing the ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"1", ",", "6"}], ")"}], TraditionalForm]]],
 " pair, since ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"1", ",", "2"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"2", ",", "6"}], ")"}], TraditionalForm]]],
 " are in ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"transitiveQ", "[", "div6", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"r2", "=", 
  RowBox[{"Complement", "[", 
   RowBox[{"div6", ",", 
    RowBox[{"{", 
     RowBox[{"{", 
      RowBox[{"1", ",", "6"}], "}"}], "}"}]}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "6"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"transitiveQ", "[", "r2", "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
 "9.2 ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "-ary Relations and Their Applications"
}], "Section",
 CellTags->"Section2"],

Cell[TextData[{
 "Using ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", we can construct an ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "-ary relation where ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " is a positive integer. As in the previous section, we will begin by \
defining predicates both for the elements of the relation (",
 StyleBox["tupleQ", "Input"],
 ") and for the ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "-ary relation (",
 StyleBox["nrelationQ", "Input"],
 "). The only difference here, as compared to the predicates we defined in \
the previous section, is that we do not know the length of the list that \
makes up a tuple. "
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"tupleQ", "[", "_List", "]"}], ":=", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"tupleQ", "[", "___", "]"}], ":=", "False"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"nrelationQ", "[", 
    RowBox[{"{", 
     RowBox[{"__", "?", "tupleQ"}], "}"}], "]"}], ":=", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"nrelationQ", "[", "___", "]"}], ":=", "False"}]}], "Input",
 InitializationCell->True],

Cell["\<\
Consider the following 4-ary relation that represents student records. \
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"r3", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
      "\"\<Adams\>\"", ",", "9012345", ",", "\"\<Politics\>\"", ",", "2.98"}],
       "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Woo\>\"", ",", "9100055", ",", "\"\<Film Studies\>\"", ",", 
       "4.99"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Warshall\>\"", ",", "9354321", ",", "\"\<Mathematics\>\"", ",", 
       "3.66"}], "}"}]}], "}"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "The first field represents the name of the student, the second field is the \
student ID number, the third field is the students' home department, and the \
last field stores the student's grade point average. Note that this relation \
satisfies ",
 StyleBox["nrelationQ", "Input"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"nrelationQ", "[", "r3", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "While we created a very generic ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "-ary relation predicate, you can also create more specific predicates for \
particular situations. For instance, the tuples in the relation above will \
always consist of a string, integer, string, and a floating point number. So \
we could make the following predicate specifically for that kind of \
relation."
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"studentRecordQ", "[", 
    RowBox[{"{", 
     RowBox[{"_String", ",", "_Integer", ",", "_String", ",", "_Real"}], 
     "}"}], "]"}], ":=", "True"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"studentRecordQ", "[", "___", "]"}], ":=", "False"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"studentRelationQ", "[", 
    RowBox[{"{", 
     RowBox[{"__", "?", "studentRecordQ"}], "}"}], "]"}], ":=", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"studentRelationQ", "[", "___", "]"}], ":=", "False"}]}], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"studentRelationQ", "[", "r3", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 "Operations on ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "-ary Relations"
}], "Subsection",
 CellTags->"Section2a"],

Cell[TextData[{
 "Now we will create functions that act on ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "-ary relations to compute projections and the join of relations."
}], "Text"],

Cell[CellGroupData[{

Cell["Projection", "Subsubsection"],

Cell[TextData[{
 "We will construct a function for computing a projection of a relation. The \
function takes as input an expression satisfying ",
 StyleBox["nrelationQ", "Input"],
 " along with a list of integers representing the indices of the fields that \
are to remain. The output will be another ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "-ary relation."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"projectRelation", "[", 
   RowBox[{
    RowBox[{"R_", "?", "nrelationQ"}], ",", 
    RowBox[{"P", ":", 
     RowBox[{"{", "__Integer", "}"}]}]}], "]"}], ":=", 
  RowBox[{"R", "[", 
   RowBox[{"[", 
    RowBox[{"All", ",", "P"}], "]"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "The expression ",
 StyleBox["R[[All,P]]", "Input"],
 " returns the list formed by taking every element of ",
 StyleBox["R", "Input"],
 " and extracting the sublist defined by the indices in the list ",
 StyleBox["P", "Input"],
 "."
}], "Text"],

Cell["\<\
We can use this function with the relation we created earlier. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"projectRelation", "[", 
  RowBox[{"r3", ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "4"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"9012345", ",", "2.98`"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"9100055", ",", "4.99`"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"9354321", ",", "3.66`"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"projectRelation", "[", 
  RowBox[{"r3", ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "4", ",", "1"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"\<\"Politics\"\>", ",", "2.98`", ",", "\<\"Adams\"\>"}], "}"}], 
   ",", 
   RowBox[{"{", 
    RowBox[{"\<\"Film Studies\"\>", ",", "4.99`", ",", "\<\"Woo\"\>"}], "}"}],
    ",", 
   RowBox[{"{", 
    RowBox[{"\<\"Mathematics\"\>", ",", "3.66`", ",", "\<\"Warshall\"\>"}], 
    "}"}]}], "}"}]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Join", "Subsubsection"],

Cell["\<\
Now let's consider joins of relations. The join operation has applications to \
databases when tables of information need to be combined in a meaningful \
manner.\
\>", "Text"],

Cell["\<\
The join function that we will implement here follows the following outline.\
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
 "Input two relations ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " and a positive integer ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]]],
 ", representing the overlap between the relations."
}], "Item1Numbered"],

Cell[TextData[{
 "Examine each element ",
 Cell[BoxData[
  FormBox["u", TraditionalForm]]],
 " of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " and determine the last ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]]],
 " fields of ",
 Cell[BoxData[
  FormBox["u", TraditionalForm]]],
 "."
}], "Item1Numbered"],

Cell[TextData[{
 "Examine all elements ",
 Cell[BoxData[
  FormBox["v", TraditionalForm]]],
 " of ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " to determine if the first ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]]],
 " fields of ",
 Cell[BoxData[
  FormBox["v", TraditionalForm]]],
 " match the last ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]]],
 " fields of ",
 Cell[BoxData[
  FormBox["u", TraditionalForm]]],
 "."
}], "Item1Numbered"],

Cell[TextData[{
 "Upon finding a match, we combine the elements and place the result in a \
relation ",
 Cell[BoxData[
  FormBox["T", TraditionalForm]]],
 ", which is returned as the output of the function."
}], "Item1Numbered"]
}, Open  ]],

Cell[BoxData[
 RowBox[{
  RowBox[{"joinRelation", "[", 
   RowBox[{
    RowBox[{"R_", "?", "nrelationQ"}], ",", 
    RowBox[{"S_", "?", "nrelationQ"}], ",", "p_Integer"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
     "overlapR", ",", "i", ",", "u", ",", "v", ",", "x", ",", "joinElement", 
      ",", 
      RowBox[{"T", "=", 
       RowBox[{"{", "}"}]}]}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Do", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{
        RowBox[{"x", "=", 
         RowBox[{"u", "[", 
          RowBox[{"[", 
           RowBox[{
            RowBox[{"-", "p"}], ";;", 
            RowBox[{"-", "1"}]}], "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
        
        RowBox[{"Do", "[", "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{"If", "[", 
           RowBox[{
            RowBox[{
             RowBox[{"v", "[", 
              RowBox[{"[", 
               RowBox[{"1", ";;", "p"}], "]"}], "]"}], "\[Equal]", "x"}], ",",
             "\[IndentingNewLine]", 
            RowBox[{
             RowBox[{"joinElement", "=", 
              RowBox[{"Join", "[", 
               RowBox[{"u", ",", 
                RowBox[{"v", "[", 
                 RowBox[{"[", 
                  RowBox[{
                   RowBox[{"p", "+", "1"}], ";;", 
                   RowBox[{"-", "1"}]}], "]"}], "]"}]}], "]"}]}], ";", 
             "\[IndentingNewLine]", 
             RowBox[{"AppendTo", "[", 
              RowBox[{"T", ",", "joinElement"}], "]"}]}]}], 
           "\[IndentingNewLine]", "]"}], "\[IndentingNewLine]", ",", 
          RowBox[{"{", 
           RowBox[{"v", ",", "S"}], "}"}]}], "]"}]}], "\[IndentingNewLine]", 
       ",", 
       RowBox[{"{", 
        RowBox[{"u", ",", "R"}], "}"}]}], "]"}], ";", "\[IndentingNewLine]", 
     "T"}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "The ",
 StyleBox["joinRelation", "Input"],
 " function beings by initializing the return relation, ",
 StyleBox["T", "Input"],
 ", to the empty list. The outer ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " loop assigns the variable ",
 StyleBox["u", "Input"],
 " to each tuple in the relation ",
 StyleBox["R", "Input"],
 ". It immediately assigns ",
 StyleBox["x", "Input"],
 " to the last ",
 StyleBox["p", "Input"],
 " elements of ",
 StyleBox["u", "Input"],
 ". This is the portion that is supposed to overlap with elements from the \
other relation. Note the use of the ",
 StyleBox[ButtonBox["Span",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Span"], "FunctionLink"],
 " (",
 StyleBox[";;", "Input"],
 ") operator. The span ",
 Cell[BoxData[
  RowBox[{
   RowBox[{"-", "p"}], ";;", 
   RowBox[{"-", "1"}]}]], "myCode"],
 " in the ",
 StyleBox[ButtonBox["Part",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Part"], "FunctionLink"],
 " (",
 StyleBox["[[\[Ellipsis]]]", "Input"],
 ") applied to ",
 StyleBox["u", "Input"],
 " refers to the span from ",
 StyleBox["-p", "Input"],
 " to ",
 StyleBox["-1", "Input"],
 ", that is, from the element ",
 StyleBox["p", "Input"],
 " from the end of the list ",
 StyleBox["u", "Input"],
 " to the last element of ",
 StyleBox["u", "Input"],
 "."
}], "Text"],

Cell[TextData[{
 "The inner ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " loop assigns the variable ",
 StyleBox["v", "Input"],
 " to each tuple in the relation ",
 StyleBox["S", "Input"],
 ". The body of the loop is an ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 " statement that checks whether the first ",
 StyleBox["p", "Input"],
 " elements of ",
 StyleBox["v", "Input"],
 " agree with the last ",
 StyleBox["p", "Input"],
 " elements of ",
 StyleBox["u", "Input"],
 " (stored in ",
 StyleBox["x", "Input"],
 "). If that holds, that is, the two elements overlap, then ",
 StyleBox["joinElement", "Input"],
 " is created by applying the ",
 StyleBox[ButtonBox["Join",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Join"], "FunctionLink"],
 " function to ",
 StyleBox["u", "Input"],
 " and the rest of ",
 StyleBox["v", "Input"],
 ". This new object is then added to the relation ",
 StyleBox["T", "Input"],
 ", which is the output of the function."
}], "Text"],

Cell[TextData[{
 "We conclude this section by applying the ",
 StyleBox["joinRelation", "Input"],
 " function to Example 11 of Section 9.2."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"teachingAssignments", "=", 
   RowBox[{"{", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"\"\<Cruz\>\"", ",", "\"\<Zoology\>\"", ",", "335"}], "}"}], 
     ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"\"\<Cruz\>\"", ",", "\"\<Zoology\>\"", ",", "412"}], "}"}], 
     ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"\"\<Farber\>\"", ",", "\"\<Psychology\>\"", ",", "501"}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"\"\<Farber\>\"", ",", "\"\<Psychology\>\"", ",", "617"}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"\"\<Grammer\>\"", ",", "\"\<Physics\>\"", ",", "551"}], "}"}], 
     ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"\"\<Rosen\>\"", ",", "\"\<Computer Science\>\"", ",", "518"}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"\"\<Rosen\>\"", ",", "\"\<Mathematics\>\"", ",", "575"}], 
      "}"}]}], "}"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"classSchedule", "=", 
   RowBox[{"{", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
      "\"\<Computer Science\>\"", ",", "518", ",", "\"\<N521\>\"", ",", 
       "\"\<2:00 P.M.\>\""}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Mathematics\>\"", ",", "575", ",", "\"\<N502\>\"", ",", 
       "\"\<3:00 P.M.\>\""}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Mathematics\>\"", ",", "611", ",", "\"\<N521\>\"", ",", 
       "\"\<4:00 P.M.\>\""}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Physics\>\"", ",", "544", ",", "\"\<B505\>\"", ",", 
       "\"\<4:00 P.M.\>\""}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Psychology\>\"", ",", "501", ",", "\"\<A100\>\"", ",", 
       "\"\<3:00 P.M.\>\""}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Psychology\>\"", ",", "617", ",", "\"\<A110\>\"", ",", 
       "\"\<11:00 A.M.\>\""}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Zoology\>\"", ",", "335", ",", "\"\<A100\>\"", ",", 
       "\"\<9:00 A.M.\>\""}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{
      "\"\<Zoology\>\"", ",", "412", ",", "\"\<A100\>\"", ",", 
       "\"\<8:00 A.M.\>\""}], "}"}]}], "}"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "We apply ",
 StyleBox["joinRelation", "Input"],
 " and use ",
 StyleBox[ButtonBox["TableForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TableForm"], "FunctionLink"],
 " to make the output readable."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"joinRelation", "[", 
   RowBox[{"teachingAssignments", ",", "classSchedule", ",", "2"}], "]"}], "//",
   "TableForm"}]], "Input"],

Cell[BoxData[
 TagBox[GridBox[{
    {"\<\"Cruz\"\>", "\<\"Zoology\"\>", 
     "335", "\<\"A100\"\>", "\<\"9:00 A.M.\"\>"},
    {"\<\"Cruz\"\>", "\<\"Zoology\"\>", 
     "412", "\<\"A100\"\>", "\<\"8:00 A.M.\"\>"},
    {"\<\"Farber\"\>", "\<\"Psychology\"\>", 
     "501", "\<\"A100\"\>", "\<\"3:00 P.M.\"\>"},
    {"\<\"Farber\"\>", "\<\"Psychology\"\>", 
     "617", "\<\"A110\"\>", "\<\"11:00 A.M.\"\>"},
    {"\<\"Rosen\"\>", "\<\"Computer Science\"\>", 
     "518", "\<\"N521\"\>", "\<\"2:00 P.M.\"\>"},
    {"\<\"Rosen\"\>", "\<\"Mathematics\"\>", 
     "575", "\<\"N502\"\>", "\<\"3:00 P.M.\"\>"}
   },
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}},
   GridBoxSpacings->{"Columns" -> {
       Offset[0.27999999999999997`], {
        Offset[2.0999999999999996`]}, 
       Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
       Offset[0.2], {
        Offset[0.4]}, 
       Offset[0.2]}, "RowsIndexed" -> {}}],
  Function[BoxForm`e$, 
   TableForm[BoxForm`e$]]]], "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["9.3 Representing Relations", "Section",
 CellTags->"Section3"],

Cell["\<\
From this point forward, we will consider exclusively binary relations. This \
gives us additional options for how we represent relations. In this section, \
we will see how to represent binary relations with zero-one matrices and \
digraphs.\
\>", "Text"],

Cell[CellGroupData[{

Cell["Representing Relations Using Matrices", "Subsection",
 CellTags->"Section3a"],

Cell["\<\
We begin with representations of relations with zero-one matrices. \
\>", "Text"],

Cell[CellGroupData[{

Cell["A First Example", "Subsubsection"],

Cell[TextData[{
 "We create a matrix as a list of lists, where the inner lists store the \
elements in the rows of the matrix. The ",
 StyleBox[ButtonBox["MatrixForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MatrixForm"], "FunctionLink"],
 " function will display the matrix in the usual form."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"{", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"1", ",", "2"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"3", ",", "4"}], "}"}]}], "}"}], "//", "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "2"},
     {"3", "4"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Be careful to not use ",
 StyleBox[ButtonBox["MatrixForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MatrixForm"], "FunctionLink"],
 " in conjunction with an assignment, lest the ",
 StyleBox[ButtonBox["MatrixForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MatrixForm"], "FunctionLink"],
 " be permanently attached to the matrix, which can cause other functions to \
fail."
}], "Text"],

Cell[TextData[{
 "When working with matrix representations of relations, it can be useful to \
begin with a matrix of the correct size filled entirely with 0s, and then \
modify that matrix as needed. To do this, you can use the ",
 StyleBox[ButtonBox["ConstantArray",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ConstantArray"], "FunctionLink"],
 " function. The first argument to ",
 StyleBox[ButtonBox["ConstantArray",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ConstantArray"], "FunctionLink"],
 " is the constant that will be used as the filler in the resulting list. The \
second argument specifies the dimension. For an ordinary list, the second \
argument is the length of the list. For a matrix, the second argument must be \
a pair specifying the number of rows and the number of columns. "
}], "Text"],

Cell[TextData[{
 "For example, to create a ",
 Cell[BoxData[
  FormBox[
   RowBox[{"4", "\[Times]", "4"}], TraditionalForm]]],
 " matrix filled with 0s, you would enter the following expression."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"exampleMatrix", "=", 
   RowBox[{"ConstantArray", "[", 
    RowBox[{"0", ",", 
     RowBox[{"{", 
      RowBox[{"4", ",", "4"}], "}"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"exampleMatrix", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"0", "0", "0", "0"},
     {"0", "0", "0", "0"},
     {"0", "0", "0", "0"},
     {"0", "0", "0", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Right now, this matrix doesn't represent a very interesting relation. We \
need to change entries to 1 to represent elements of the domain that are \
related to each other. For instance, if ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"1", ",", "2"}], ")"}], "\[Element]", "R"}], TraditionalForm]]],
 " then we need to change the ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"1", ",", "2"}], ")"}], TraditionalForm]]],
 " entry to a 1. To do this, we use ",
 StyleBox[ButtonBox["Part",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Part"], "FunctionLink"],
 " (",
 StyleBox["[[\[Ellipsis]]]", "Input"],
 ") and ",
 StyleBox[ButtonBox["Set",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Set"], "FunctionLink"],
 " (",
 StyleBox["=", "Input"],
 ") to specify the location and make the assignment."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"exampleMatrix", "[", 
   RowBox[{"[", 
    RowBox[{"1", ",", "2"}], "]"}], "]"}], "=", "1"}]], "Input",
 InitializationCell->True],

Cell[BoxData["1"], "Output"]
}, Open  ]],

Cell["We can see that it modified the matrix.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"exampleMatrix", "//", "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"0", "1", "0", "0"},
     {"0", "0", "0", "0"},
     {"0", "0", "0", "0"},
     {"0", "0", "0", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Let's make this matrix represent the relation \[OpenCurlyDoubleQuote]is one \
less than\[CloseCurlyDoubleQuote] on ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4"}], "}"}], TraditionalForm]]],
 ", as in, \[OpenCurlyDoubleQuote]1 is one less than 2.\
\[CloseCurlyDoubleQuote]"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"exampleMatrix", "[", 
    RowBox[{"[", 
     RowBox[{"2", ",", "3"}], "]"}], "]"}], "=", "1"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"exampleMatrix", "[", 
    RowBox[{"[", 
     RowBox[{"3", ",", "4"}], "]"}], "]"}], "=", "1"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"exampleMatrix", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"0", "1", "0", "0"},
     {"0", "0", "1", "0"},
     {"0", "0", "0", "1"},
     {"0", "0", "0", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["\<\
Transforming a Set of Pairs Representation into a Matrix Representation\
\>", "Subsubsection"],

Cell[TextData[{
 "Now we'll create a function to turn a relation satisfying ",
 StyleBox["relationQ", "Input"],
 " (defined in the first section) into a matrix representation. Doing so is \
fairly straightforward. Given a relation ",
 StyleBox["R", "Input"],
 ", whose domain consists of integers, we can use ",
 StyleBox["findDomain", "Input"],
 " from above to extract the domain. We then create a square matrix whose \
size is equal to the largest integer in the domain, which we can obtain with \
the ",
 StyleBox[ButtonBox["Max",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Max"], "FunctionLink"],
 " function. Then we simply loop through the elements of the relation and set \
the value of the corresponding entry in the matrix to 1."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"relationToMatrix", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"u", ",", "max", ",", "m"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"max", "=", 
      RowBox[{"Max", "[", 
       RowBox[{"findDomain", "[", "R", "]"}], "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"m", "=", 
      RowBox[{"ConstantArray", "[", 
       RowBox[{"0", ",", 
        RowBox[{"{", 
         RowBox[{"max", ",", "max"}], "}"}]}], "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{"m", "=", 
        RowBox[{"ReplacePart", "[", 
         RowBox[{"m", ",", 
          RowBox[{"u", "\[Rule]", "1"}]}], "]"}]}], "\[IndentingNewLine]", 
       ",", 
       RowBox[{"{", 
        RowBox[{"u", ",", "R"}], "}"}]}], "]"}], ";", "\[IndentingNewLine]", 
     "m"}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "Note the use of ",
 StyleBox[ButtonBox["ReplacePart",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ReplacePart"], "FunctionLink"],
 " to modify the matrix ",
 StyleBox["m", "Input"],
 ". Recall that elements of the relation ",
 StyleBox["R", "Input"],
 " are pairs, such as ",
 StyleBox["{1,2}", "Input"],
 ". The expression ",
 Cell[BoxData[
  RowBox[{
   RowBox[{"m", "[", 
    RowBox[{"[", "u", "]"}], "]"}], "=", "1"}]], "myCode"],
 ", therefore, would be resolved to an expression of the form ",
 Cell[BoxData[
  RowBox[{
   RowBox[{"m", "[", 
    RowBox[{"[", 
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], "]"}], "]"}], "=", "1"}]], "myCode"],
 ". This does not set the ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"1", ",", "2"}], ")"}], TraditionalForm]]],
 " element of ",
 StyleBox["m", "Input"],
 " to 1, however. Rather, ",
 StyleBox["m[[{1,2}]]", "Input"],
 " represents the list consisting of the first element and second element of ",
 StyleBox["m", "Input"],
 ", that is, ",
 StyleBox["m[[{1,2}]]", "Input"],
 " is the first two rows of ",
 StyleBox["m", "Input"],
 ".",
 " ",
 StyleBox[ButtonBox["ReplacePart",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ReplacePart"], "FunctionLink"],
 " allows us to use the pair {1,2} to reference the ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"1", ",", "2"}], ")"}], TraditionalForm]]],
 " entry of ",
 StyleBox["m", "Input"],
 ". The ",
 StyleBox[ButtonBox["ReplacePart",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ReplacePart"], "FunctionLink"],
 " function\[CloseCurlyQuote]s first argument is an expression to be \
manipulated, such as the matrix ",
 StyleBox["m", "Input"],
 ". Its second argument is a ",
 StyleBox[ButtonBox["Rule",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Rule"], "FunctionLink"],
 " (",
 StyleBox["->", "Input"],
 ") with left operand a location specification and right operand the new \
value. "
}], "Text"],

Cell[TextData[{
 "We use the function above to convert the relations we defined earlier, \
specifically ",
 StyleBox["div6", "Input"],
 " and ",
 StyleBox["divOrMul6", "Input"],
 " into matrices."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"div6M", "=", 
   RowBox[{"relationToMatrix", "[", "div6", "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"div6M", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1", "1", "1", "1"},
     {"0", "1", "0", "1", "0", "1"},
     {"0", "0", "1", "0", "0", "1"},
     {"0", "0", "0", "1", "0", "0"},
     {"0", "0", "0", "0", "1", "0"},
     {"0", "0", "0", "0", "0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"divOrMul6M", "=", 
   RowBox[{"relationToMatrix", "[", "divOrMul6", "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"divOrMul6M", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1", "1", "1", "1"},
     {"1", "1", "0", "1", "0", "1"},
     {"1", "0", "1", "0", "0", "1"},
     {"1", "1", "0", "1", "0", "0"},
     {"1", "0", "0", "0", "1", "0"},
     {"1", "1", "1", "0", "0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell["\<\
As before, it can be useful to have a predicate that we can use to ensure \
that an argument to a function is in fact the matrix associated to a \
relation. Any such matrix must be square and consist entirely of 0s and 1s.\
\>", "Text"],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["MatrixQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MatrixQ"], "FunctionLink"],
 " function can be used to ensure that an expression does represent a matrix. \
It requires only one argument and returns ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 " only if the expression is a list of lists. ",
 StyleBox[ButtonBox["MatrixQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MatrixQ"], "FunctionLink"],
 " can also accept a second optional argument to place specific demands on \
the allowed elements of the matrix. Here, we insist that the elements be 0 or \
1. So we create a pure ",
 StyleBox[ButtonBox["Function",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Function"], "FunctionLink"],
 " (",
 StyleBox["&", "Input"],
 ") that tests equality for 0 or 1."
}], "Text"],

Cell[TextData[{
 "The other requirement is that the matrix be square. We use the ",
 StyleBox[ButtonBox["Dimensions",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Dimensions"], "FunctionLink"],
 " function to obtain a list containing the number of rows and columns and \
compare those values. Here is the predicate. "
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"matrix01Q", "[", "m_List", "]"}], ":=", 
   RowBox[{
    RowBox[{"MatrixQ", "[", 
     RowBox[{"m", ",", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{
         RowBox[{"#", "\[Equal]", "0"}], "||", 
         RowBox[{"#", "\[Equal]", "1"}]}], ")"}], "&"}]}], "]"}], "&&", 
    RowBox[{
     RowBox[{
      RowBox[{"Dimensions", "[", "m", "]"}], "[", 
      RowBox[{"[", "1", "]"}], "]"}], "\[Equal]", 
     RowBox[{
      RowBox[{"Dimensions", "[", "m", "]"}], "[", 
      RowBox[{"[", "2", "]"}], "]"}]}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"matrix01Q", "[", "___", "]"}], "=", "False"}], ";"}]}], "Input",
 InitializationCell->True],

Cell["\<\
Now that we have zero-one matrix representations of relations to work with, \
we can use these matrices to determine which properties apply to them. In \
this form, it is sometimes easier to determine whether a relation is \
reflexive, symmetric, or antisymmetric. \
\>", "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Checking Properties", "Subsubsection"],

Cell["\<\
For example, to determine whether or not a relation is reflexive from its \
zero-one matrix representation, we only need to check the diagonal entries. \
If any diagonal entry is 0, then the relation is not reflexive. \
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"reflexiveMatrixQ", "[", 
   RowBox[{"m_", "?", "matrix01Q"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"i", ",", "dim"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"dim", "=", 
      RowBox[{
       RowBox[{"Dimensions", "[", "m", "]"}], "[", 
       RowBox[{"[", "1", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"Catch", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"For", "[", 
        RowBox[{
         RowBox[{"i", "=", "1"}], ",", 
         RowBox[{"i", "\[LessEqual]", "dim"}], ",", 
         RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"m", "[", 
             RowBox[{"[", 
              RowBox[{"i", ",", "i"}], "]"}], "]"}], "\[Equal]", "0"}], ",", 
           RowBox[{"Throw", "[", "False", "]"}]}], "]"}]}], 
        "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
       RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", 
      "]"}]}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell["We can now use this to test a few of the relations above. ", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"reflexiveMatrixQ", "[", "exampleMatrix", "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"reflexiveMatrixQ", "[", "div6M", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "Symmetry is particularly easy to test, because of the fact that a relation \
is symmetric if and only if its matrix representation is symmetric. ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " has a built-in test, ",
 StyleBox[ButtonBox["SymmetricMatrixQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SymmetricMatrixQ"], "FunctionLink"],
 " that checks symmetry."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SymmetricMatrixQ", "[", "div6M", "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SymmetricMatrixQ", "[", "divOrMul6M", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Representing Relations Using Digraphs", "Subsection",
 CellTags->"Section3b"],

Cell[TextData[{
 "Now we turn to representing relations with directed graphs, commonly called \
digraphs. You can draw a graph in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " with the ",
 StyleBox[ButtonBox["GraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/GraphPlot"], "FunctionLink"],
 " function. For graphs representing relations, the ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " function often produces a more informative plot. The two functions have \
very similar options and syntax, although the defaults differ. Here, we focus \
on ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 "."
}], "Text"],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " function can take a wide variety of options, but its only requirement is a \
list specifying the edges in the graph given as rules. For example, consider \
Bob and his sister Barb, whose parents are Ann and Abe. We can make a \
directed graph representing the relation \[OpenCurlyDoubleQuote]parent of\
\[CloseCurlyDoubleQuote] as follows."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"LayeredGraphPlot", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"\"\<Ann\>\"", "\[Rule]", "\"\<Bob\>\""}], ",", 
    RowBox[{"\"\<Ann\>\"", "\[Rule]", "\"\<Barb\>\""}], ",", 
    RowBox[{"\"\<Abe\>\"", "\[Rule]", "\"\<Bob\>\""}], ",", 
    RowBox[{"\"\<Abe\>\"", "\[Rule]", "\"\<Barb\>\""}]}], "}"}], 
  "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[{{0., 1.}, {0., 0.}, {1., 0.}, {1., 1.}}, {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.041582132564841494`, 0.8}}], 
      ArrowBox[{1, 2}], ArrowBox[{1, 3}], ArrowBox[{4, 2}], ArrowBox[{4, 3}]}, 
     {RGBColor[0, 0, 0.7], 
      TagBox[
       TooltipBox[PointBox[1],
        "\"Ann\"",
        TooltipStyle->"TextStyling"],
       Annotation[#, "Ann", "Tooltip"]& ], 
      TagBox[
       TooltipBox[PointBox[2],
        "\"Bob\"",
        TooltipStyle->"TextStyling"],
       Annotation[#, "Bob", "Tooltip"]& ], 
      TagBox[
       TooltipBox[PointBox[3],
        "\"Barb\"",
        TooltipStyle->"TextStyling"],
       Annotation[#, "Barb", "Tooltip"]& ], 
      TagBox[
       TooltipBox[PointBox[4],
        "\"Abe\"",
        TooltipStyle->"TextStyling"],
       Annotation[#, "Abe", "Tooltip"]& ]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 1.}, {0., 0.}, {1., 0.}, {1., 1.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "To make this more informative, we\[CloseCurlyQuote]ll need to provide some \
options. In particular, we want to see the names of the people associated \
with each vertex. To do this, we use the option ",
 StyleBox[ButtonBox["VertexLabeling",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/VertexLabeling"], "FunctionLink"],
 " with value ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 ". "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"LayeredGraphPlot", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"\"\<Ann\>\"", "\[Rule]", "\"\<Bob\>\""}], ",", 
     RowBox[{"\"\<Ann\>\"", "\[Rule]", "\"\<Barb\>\""}], ",", 
     RowBox[{"\"\<Abe\>\"", "\[Rule]", "\"\<Bob\>\""}], ",", 
     RowBox[{"\"\<Abe\>\"", "\[Rule]", "\"\<Barb\>\""}]}], "}"}], ",", 
   RowBox[{"VertexLabeling", "\[Rule]", "True"}]}], "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[{{0., 1.}, {0., 0.}, {1., 0.}, {1., 1.}}, {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.041582132564841494`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{1, 3}], ArrowBox[{4, 2}], 
      ArrowBox[{4, 3}]}, {InsetBox[
       FrameBox["\<\"Ann\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["\<\"Bob\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["\<\"Barb\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["\<\"Abe\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 1.}, {0., 0.}, {1., 0.}, {1., 1.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Other values for ",
 StyleBox[ButtonBox["VertexLabeling",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/VertexLabeling"], "FunctionLink"],
 " are ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 ", in which no labels are displayed; ",
 StyleBox[ButtonBox["Tooltip",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Tooltip"], "FunctionLink"],
 ", in which labels are displayed if you hover the mouse over the vertex; ",
 StyleBox[ButtonBox["All",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/All"], "FunctionLink"],
 ", which gives both labels and tooltips; and ",
 StyleBox[ButtonBox["Automatic",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Automatic"], "FunctionLink"],
 ", which displays labels as tooltips provided the number of vertices is not \
too large. "
}], "Text"],

Cell[TextData[{
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " can also be applied to an adjacency matrix, rather than a list of rules \
representing edges. The following draws a graph of the \
\[OpenCurlyDoubleQuote]divisible\[CloseCurlyDoubleQuote] relation using the \
",
 StyleBox["div6M", "Input"],
 " matrix. Note that the labels in this case are automatically chosen to be \
the integers from 1 to ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 ", where ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " is the size of the matrix. "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"LayeredGraphPlot", "[", 
  RowBox[{"div6M", ",", 
   RowBox[{"VertexLabeling", "\[Rule]", "True"}]}], "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[CompressedData["
1:eJx1kWtIk1EYx2firWyCmlqWoYhaRH3IS4n5rygymJN0M0stDLUiLxBJZpol
tfKW2oQwRMmsFplaRLllHFOMylS6zUuJbzPLOdfmNi+b8zWN3heS+nMOD79z
nud8OD/PI+mRSUs4HE7I/F6oi7L9b9TiP5Usmmv5dx/7Dll0vp3hiuVBAbda
JeTanujvo1vn4NFQF9XfJiPcgPaDrVE0sporVnSK28nJV7x4Ufgs/HTXS8Ne
dpFmC7U60NcMXvaxzobsj0RN3bb/SJnw7ajXqnyXfmKTfFoan2WEZiDENcaN
IrZlCYYP+imsCQm6dC1piOgSEp8Hhk/iLJ/To9d9J629uc4ikQExYuEK9I2Q
pAJvvk+uHl0XhTyBaJQMFjtuU5/QQeHFyd5sUpFNQ3u/9vPGUZIqrP3iryaC
gjfBGk8t5InC9ojAn6Taep1YIFdDassZLKJ/kp2VEe5u+1QIPCAcFxdrSNkn
W+66xyPgRwvNiUMaUvRIcOLy3DD7v5t/Z4jlqoeFPUinWO5yKCy/cPczLP6w
a8oLl5QXcvZ+ZaYsABvesyw5OqaY6O5guTxUKQ5VtrFMKeXmxjApy/T6t/lc
KwnSicRs0DXBUrYq5tiWObxxLFXkeHfgAy33bAqnUVl0wOUSR47ULv94DWZx
XnqovuTyIN75+S/lOphh9+p+XIPTMOjln/ycn5ngY1vjbtSMYjLHVWqxy4ir
XLuCyDotmjJnZPJ7U8iwpGv6fAzYTZ/fKB6bwEtFQ2/ZjylUciVOQfYGtNSr
lvFERjT57CB5Hno8sTrslfzahJKMOkutpw61P+xWU40z8JhRUudcxnFFMDYt
DTHjdZr+waFpDZJ51lJ9yjwLnnYsuaNGaPf+uOIdZgRL1rqPBqjAHaAUItkM
Vh/fUOksGUFvxk0e1WNC+vUBfp55GDcqFmIE46e7t11VHTQNxo++zSuJUk6C
8WMT22gV2zgBxo9NVVqnQ6EBjJ+Jovhm+owejJ/3vjnzSwfGz+/28nEwfmIS
+Kf8WrRg/PwCiRew3A==
    "], {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.028937842778793414`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{1, 3}], 
      ArrowBox[{1, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 
       24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 4}], ArrowBox[{1, 5}], 
      ArrowBox[{1, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
        50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 6}], ArrowBox[{2, 4}], 
      ArrowBox[{2, 6}], ArrowBox[{3, 6}]}, {InsetBox[
       FrameBox["1",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["2",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["3",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["4",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["5",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["6",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 2.}, {0., 1.}, {1., 1.}, {-1., 0.}, {-2., 
     1.}, {1., 0.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Note that when using a matrix representation, the fact that the relation is \
reflexive is not represented by default. You can have ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " display loops indicating reflexivity by using the option ",
 StyleBox["SelfLoopStyle->All", "Input"],
 "."
}], "Text"],

Cell[TextData[{
 "In order to represent a relation satisfying ",
 StyleBox["relationQ", "Input"],
 " as a graph, we'll create a function ",
 StyleBox["drawRelation", "Input"],
 ". At minimum, we need to transform the ordered pairs of the relation into \
the rules that ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " requires. To do this, we can use the ",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 " function at level 1 as shown below."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Apply", "[", 
  RowBox[{"Rule", ",", "div6", ",", 
   RowBox[{"{", "1", "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"1", "\[Rule]", "1"}], ",", 
   RowBox[{"1", "\[Rule]", "2"}], ",", 
   RowBox[{"1", "\[Rule]", "3"}], ",", 
   RowBox[{"1", "\[Rule]", "4"}], ",", 
   RowBox[{"1", "\[Rule]", "5"}], ",", 
   RowBox[{"1", "\[Rule]", "6"}], ",", 
   RowBox[{"2", "\[Rule]", "2"}], ",", 
   RowBox[{"2", "\[Rule]", "4"}], ",", 
   RowBox[{"2", "\[Rule]", "6"}], ",", 
   RowBox[{"3", "\[Rule]", "3"}], ",", 
   RowBox[{"3", "\[Rule]", "6"}], ",", 
   RowBox[{"4", "\[Rule]", "4"}], ",", 
   RowBox[{"5", "\[Rule]", "5"}], ",", 
   RowBox[{"6", "\[Rule]", "6"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Recall that ",
 StyleBox["@@@", "Input"],
 " is the operator form of the above expression."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Rule", "@@@", "div6"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"1", "\[Rule]", "1"}], ",", 
   RowBox[{"1", "\[Rule]", "2"}], ",", 
   RowBox[{"1", "\[Rule]", "3"}], ",", 
   RowBox[{"1", "\[Rule]", "4"}], ",", 
   RowBox[{"1", "\[Rule]", "5"}], ",", 
   RowBox[{"1", "\[Rule]", "6"}], ",", 
   RowBox[{"2", "\[Rule]", "2"}], ",", 
   RowBox[{"2", "\[Rule]", "4"}], ",", 
   RowBox[{"2", "\[Rule]", "6"}], ",", 
   RowBox[{"3", "\[Rule]", "3"}], ",", 
   RowBox[{"3", "\[Rule]", "6"}], ",", 
   RowBox[{"4", "\[Rule]", "4"}], ",", 
   RowBox[{"5", "\[Rule]", "5"}], ",", 
   RowBox[{"6", "\[Rule]", "6"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["That is all that is necessary to graph the relation.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"LayeredGraphPlot", "[", 
  RowBox[{
   RowBox[{"Rule", "@@@", "div6"}], ",", 
   RowBox[{"VertexLabeling", "\[Rule]", "True"}]}], "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[CompressedData["
1:eJx1Vgk4lFsfn6FBsqQiUrYUSnVvhRb1H6Xtu9LCFG0SKlvKEqW+VJayhEhR
oZuyFap7C9F5U1T2LGOvMcY2aPbB0PjcO8vzfPf5vvO873Oe33vO+S+/3/+8
5+if8NnvJoPD4Sqm37/6fzTif0Mm/J8e/WMd9r/nSe2gf3wnSnCysoXZ47Is
dHvHgT76+inQyX9m1/6hGKmYlR8qsxPCxZJk9ZqEcuT72eZo+O6fYMy+G7ez
ohaV4EdGzI0mwebS6Zr8S01ohPJEqYkiANopgwU3NdqR/MnAoqMXx4HRZTnf
QZOCFOKduY2cUVhkaRF2260HsZ1dS8138yHYFtfCYfehstYr88LDueCQQFKH
tgHkFmlou/QKB2pDSTb24XT0PWbOphFPNlANcJfWCIbQqp5d3e02LIj1JmV0
rh1B9pGVGxj6TCC7ksr3mP9AaXImCfbkEShSwH2PFv5AWx7s0dbcNwTmjiRW
QgwDxTcrqJj8MQC2B0iTrj0MFP3S3jNiqlfK75q/W48Up76IagEfihTXqkYl
Xs3sALwYz/d6r+H1niwd1woqNgPTBinOOjVM5dVVSXHi5sGEzYMfpJgySJ4s
2FkkxcJl1TdVCFngg7ImuexCkC1e4HB63RRUzomjXjasgkYhWb9wtxAeRDtq
hOHI4F279igDfkJI0bG82Ijv8NV4raKK6iTM/Jx7JH9uLwiVm43nvRXAUoXf
tccZdOBfnl+Etx6HWyozI/c/Y0Jh0EQxOXsUAmSFv7ct5cI2YcjKhGEeVFDz
W+P7R+GBStZcCyUuYHlDs2zCx6FwqRW6psOB1wQng5NfBBAb8EyWqc+GjP6Z
CykFE6AzMUj5twYLbtgPjxVZTsKXM5znx8YYcNJGrojjNY3t31TJPB2BzXUH
j8RYTcKGLF1tutkQqHRRqOHFE7DQ3fTBvKwBaA14ZENpEYDP3S7ba5O9kJL8
VxsHiT51reVDaRZjINGH88HAjTLIB4k+8ocLCIcLeCDRRz71TI1qFBck+vCi
j5YIL3BAok+D0eXphw0Sff6ensgCiT4Ozrb+xhgTJPo4PY8I2+gahGjptbN+
nd5XLlcK6x7nliAPmUFdZIAjNiUu8VtSVonu0V2Na0JwRDbXN/NqaAMqL1lR
XzcHT/Q3jwp+uZyMugX5vbNr8MQOx6e9j2a1IlKAVmtaugyx2d61vf5nC5Lt
8bgcekmWmPq6WfWwLBnlO8qHa++ZQfRMLdpIsW5AGbEPc0LkCcRk/P6a6zqV
aPnbExGDSQQizmyESzV7i2jPNu5vZhGIQWeVH6jPzSjxvuCsOj5bjjhDNA6S
8TjRepCsPyWyDxL7KSL/IPHfKIoPZojjaxfFDwfE8fuK8gNJfuL8QZL/VxE/
kCzm5zcRf+Au5k/ML0j4DVn+a3mb73MYrTpxx6aZA/OWp5xffO1PUDS/3/hF
yIXEhZSWPhMMcng2+nx5PrwZsD2wcc8nkM2r15vZwwdjw90kwdc6IJEDW9JC
R8HXVK/JN70J0p6PrrKnjcLdy5/3Wca2wXqNNW9Nf47CWOph3Td+32Dba3fK
t5pReLXOkeEa3g30jwuUKA6jkMUv2vb4Vg/Mdhkbs87gQ/qOJdbRFr3gobK+
4mwRD5So/AWKnn3QYd+rei+DC6edUg7oa/XDAyPtCB1/DtR7T0SUr+sH8sH1
wS0WbKA3v8/Z97kPKu7G7FiDYwG/1k4+taYX9FSLV34pZoBJl6/3SxIN2P2B
pWqlI1BzfWuDpj8VDmRMBb7TH4ZN+A/2bVYUkCko8fxFSIc1BcyDhwo7oDFz
XHjLmQ7b80kPOeVkuP1CsFtoRwfXx5rq+358hS3/km9dTaaDTxDvVFlPJbzo
L1l0unsI6IPbdRV/MMDPi++fp8GEy9ktX/foM6Av0lv3VBkLUjt1+tNtGFBr
1bMjd3ofXQuy5ViZM2HFzN7JzVo8yLp4MIu5lgUuNvql1Vf40Fc+RvsRw4bw
k06c+LhRuLfg3I24JVxw++Nh+HOzMZA9smH94g4erKl/otvtPAYOVKwyJmoU
XPEvFjxSG4OgTwKO3rxx6Nk6aX/0t1EoHsqOcCIJQO6d49SkDh/kzgUrh5lN
QJeY78XlL78l/T4BJr+5hd4QsME9P4LUnDAB7zpOGk5sYcHxFfa+PooT4N/2
4KrLFga8nv0mxkNNABWF7gHHvIehsO2tIlYyBtn3fD6pWNFhh2Bi1QejUYie
FdI4lz4Ay3Y1KTN9ebBsKsCNeX0ADO64+O19z4Ecn/S6Zo1BWOcS4PfMjA2W
b3QKJpLoQPGGVRiDCfofH/bE9w5DhXLCLwUzmVCltm3T+kYGfBL1KCRae6nz
cRekJ5qHcCUj/YSx50hsB/2plXvf5fl7lC3yg5SyF96/rliLjEVxoKeG+yyw
qmYUKYoTaQ4ykFJaJ3oqygOdfRWoHnKhG30U5Yk89M9oNxvQ0FkRDwg7lEX7
Nq8PlYp4Qg3HVHNzjPqRmEe0PdKtdMW2ftQp4hmJ6xwRRDog/xY7VZRDQ1SR
Toh5i9dvZUxFJ0Q6ouM3ZZdbrPyGVot0RspnB2nRXi3IVVQH6LjHR/0tSfUo
TFQnaO2qCqNAn49IXEcoJCcwTHHPK2QqqjOkZ2WZOa4XhcR1iPZ6GS7s8UwC
mqhO0fF6xXIC+b6kjhFuvkYRhecMGxapbvThTaHO9rxNck0MmMpT68Wfm0IG
W9yXQcwwBCav7wo6NYViM/bGty8aBOs3I4y7bVMoMeAO7kR1LwSHfuzSdsJh
Q2zPlLFOKrSTaxtD8HgscRfG6omiwLvdxhu4FXgs80+TRi+1b6BJKk1KS5PB
HLSIRZO0TogI9qzWvyiL7ZJ7VBeX0zV9Xj8c51jPwJo8rwqNTCiwYvaZY18Z
09iPpde+nwrycRpeBG8CxvreYMRb0gsHkdrqsJcEzHBE5V3Q6QHIuqOWVFpM
wKpadan+LUNQMLmrmhBGwM5Efzx52pQBupWh3c/UCZhfu7ejvxoLdroLiI8C
ZmBxHXP2qgIbqmeV2Ba9kMXixhJpjXIcsA1LqM5tk8HKJs8plDhwoIuwdWWN
EI+9cQluM1vJAf2Y/ne5q/FYl13jzZxINszxf2yQGYbDjsxNI60LZkG1yYRO
OgGHLWt/YvhEnQl//841p++h6ef29odpIn7EhGVxJQtC1l7lxjrFo5SXrnnW
035wdg+VnmgVIMvSTne9R1zYUd0h89P0PXpYQ00djuSBXN7UIZWv1eh8kvuF
ARk+ZOZUYcIZzchMPdncf4oHmpoHhxbTOlCmN+8DOYQHxScXaZ6x7EYpp36o
rIvnwq3N53NkdGhoNTHnQv3W6fN/OHLR08N9aG+j7apjr1hw69WPnaRP/dJ7
84vesE20rQPouOOJR1uTh6Xj96/kKjkFDUK2eH31L4upsV19UvsvDdWD9gtp
Uv9JzTW35+NpMF8c35xGU+VVgh7IEsdf4bqhbCmdBgri/CLCtpui0j5p/tUp
5o/P7xmU8qPBVAiP8hiGs2L+njC5NyzqGFJ+/wNu+jOh
    "], {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.028937842778793414`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{1, 3}], 
      ArrowBox[{1, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 
       24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 4}], ArrowBox[{1, 5}], 
      ArrowBox[{1, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
        50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 6}], 
      ArrowBox[{1, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
        76, 77, 78, 79, 80, 81, 82, 83, 1}], ArrowBox[{2, 4}], 
      ArrowBox[{2, 6}], 
      ArrowBox[{2, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
        99, 100, 101, 102, 103, 104, 105, 106, 2}], ArrowBox[{3, 6}], 
      ArrowBox[{3, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
        119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 3}], 
      ArrowBox[{4, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141,
        142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 4}], 
      ArrowBox[{5, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
        165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 5}], 
      ArrowBox[{6, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187,
        188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 6}]}, {InsetBox[
       FrameBox["1",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["2",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["3",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["4",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["5",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["6",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 2.}, {0., 1.}, {1., 1.}, {-1., 0.}, {-2., 
     1.}, {1., 0.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The example above shows us how to define ",
 StyleBox["drawRelation", "Input"],
 ". We will also use the ",
 StyleBox[ButtonBox["SelfLoopStyle",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SelfLoopStyle"], "FunctionLink"],
 " to turn off the self-loops so as to make cleaner looking graphs."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"drawRelation", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"LayeredGraphPlot", "[", 
   RowBox[{
    RowBox[{"Rule", "@@@", "R"}], ",", 
    RowBox[{"VertexLabeling", "\[Rule]", "True"}], ",", 
    RowBox[{"SelfLoopStyle", "\[Rule]", "None"}]}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"drawRelation", "[", 
  RowBox[{"dividesRelation", "[", "10", "]"}], "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[CompressedData["
1:eJxtlQtUFFUYx2cfswus7G6CaBGaZKALGSmhkYf7qUeM8mhHSUzeKmhmUKml
JmiioEKsCCeDFBIIyIyHGYRu3ilEVsRHpkAKsoEKCMnyWB7LPmLWneE49Z07
Z85v7r1zH//73f/0dbEro/gEQZSPPfT76bCBJ28tsn5gGD/NBPX/7bjtmXo5
xaln+nHiP+Na2YbTn+CwHP6f/zOO9TuzTu44WnQiL/HaDHkVPtYkTgvMEoOH
jyF5vuw2xnG380OniSF59aR5lW/9jbe3bXrDWSkC/+B2UYR9Jz5v/3vgl50k
fOd4bq26XYuVBo32p9kkBGhCT36n1uGBkmqZMkwIafLwhqWzRnGH+0dlU3cK
4MLNsPiG/QS1ZYPm9rp4PiReVx3856yAio9yiguO4cEcv+b6z9OEVMEOyF47
mQcZP75QfdqPpFYVqN/1+JmAIpekVXtVJHXwcXHe1aUExKTK9w3aiagDuQ9l
Cdlm1GFWvSNTiCibEx6k9JgJOX6SgmufFVFZdZ7uC3Ya0cD9+Gsz75DUvFcf
bbdfYkBJazLiZn1AUq2163u/0OtRnSWEVFYmHSMourtVd91ZSF1vrO7KmTeM
9JFpc7TbBFR/lWuUpnMQ7X+5cd/LjXxKHFxKBpfqkHBFxcOkJWOcHXNVljyA
dl2aHWZW8ShdSqjKtLMfPUr360z341E33ePGSh+yNK8lKEvzjF502svd1zGC
oNZELt82k9KiWFxkGOj7BfND7T29j4uhduKR1rgZV/DmPV3yJjcxHE95z+kA
UY99NmYVD+WIYG9lWLEyqQW/7/gcmSQWga36h5AShwfYnLjZ8XAoCW42uc4j
PY/w6IXkJiJXCKlS28MrT2txiCoutOuWALYLTLl/uQ3gF/fAsYBBPlxqLWlM
ax/Cy8W3DjmL+EAVd0mWJY7g0PRvwxcqeVBOhrtGX9bjGt963rCcB/ntts9r
Skex0rjtI5RMwMHA7uHKBQYcVTGy+hWDGUUvE1X2bzHgDafuRvH+NCG/60Eh
Xy404Km3lPa6LCOSNmtaE8+N4lRvp+V2gQbUuP3kMk2DHv9yJcZ9oUmPrLpg
Rh+rLpjRx6oLZvSx6oIZfay6YEYfqy6Y0ceqC2b0seqCGX2sumBGn7Ct9+VB
PZfRnBhV3qKvxVC0SyxZ5NKMPC4W9kyaLIZP/26pipzfgTp5v7ft3C2CExcL
zMmqXvShu2RvjJqEwLUP70bOHEbl3gkX+/VCuFNW/OmZcDOqnqUos3UUQtYD
c7tfmQCyRIR/qYMAvP7s7o+cYgPeV4QJ7SM8KJ0+NXzRgwmQ8dn8TSWXCNis
kOyXpthDbMuGt1uOErArZYrLG9OkQB5Y80i1goB7S/0V6mwp/HTD7fARvRkd
Dcn44Wc7Gdyc6FHBn2dG39TyTwrWyyDmxq/BNwJNaCgtze5MoQz22bZ8NrLK
iArPQAfVKAP5hVRJvLcBnfKU+3oNymDK4zqnsEE9c/9BtCUG0cFTyy5vHKvv
nhy2coaNDk0/NeelnL9kIF7rkplc3Y9qTWUOBd/L4Kxnvu/x7D60t6g2Y3e0
DHqVfT6r03tRQOHuIle5DKgEm9TKPC1yHa1Z/nWBFBbL6/ak5PQgu/zTSc2z
pKDwdcocnv0Y8XMVq/oy7cHnQM/GCl03kugWltUPToANvUHd6v4u9JXGod0r
wRZc6mMPffVeO2p1uxMeESSCxrk7FB7T2lBPTYZz1FYBzJzUmm1/6B46X7X4
OdRAwPGzZ7Ur0xuQ0vtaRRNpRI7+m95yC/0DKY4ZqQfdw8g5fSRIdrUG+ZdM
eidzvQ69YFC/2/SrCrXtdooaer8PTfVe4pOPv2fv50DLgRUz9zJx5s1nd5x7
bZwnb/nNactvIpYTX//jJLF4nI2ldAeS5XjLgR1nG8uBFbKc6eBi53VfwLL3
XDrG+ZblvPNZ/vj5mrHCY3niM3SMcxlJJxTrT8S3AwE5AwFmdn33mukwsuxC
/+5jA8shdDqSoywz+cwwk88MM/nMMJPPLFvzmWEmnxlm8plhJp8ZZvLZ6oeI
44eI44eI44eI44eI44eI44eI44fA8UPg+CFw/BA4fggcPwSOHwLHD4Hjh8Dx
Q+D4IXD8EDh+CBw/BI4fAscPgeOHwPFD4PghMPo8UUuLCrPLkhuQmeV19DQ+
MCGelWfT09hnZOsnbM1dzEs0sPxk3qPjnL+CLuPtFzRnTXMaYflVehrqIZaZ
+43hPEv3AZbb5qeOlX52Pi+60tHH1kdKyiMk5ePrQZ30RjxmWXWeji6WX6d/
19bBMt07QvKQZUs6z21j2bI9sRqWr43t5heFd9n5PLlf6tl6+vZBnjdZLtpI
C32F5Qxaps4qljWd9YbSNytZNinqDknJIvQvxMZs5w==
    "], {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.021167650531286893`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{1, 3}], 
      ArrowBox[{1, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 4}], ArrowBox[{1, 5}], 
      ArrowBox[{1, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
        59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 6}], ArrowBox[{1, 7}], 
      ArrowBox[{1, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
        85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 
       102, 103, 104, 8}], 
      ArrowBox[{1, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,
        117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 
       9}], ArrowBox[{1, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 
       141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 
       155, 156, 10}], ArrowBox[{2, 4}], ArrowBox[{2, 6}], 
      ArrowBox[{2, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 
       8}], ArrowBox[{2, 10}], ArrowBox[{3, 6}], ArrowBox[{3, 9}], 
      ArrowBox[{4, 8}], ArrowBox[{5, 10}]}, {InsetBox[
       FrameBox["1",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["2",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["3",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["4",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["5",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["6",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6], InsetBox[
       FrameBox["7",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 7], InsetBox[
       FrameBox["8",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 8], InsetBox[
       FrameBox["9",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 9], InsetBox[
       FrameBox["10",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 10]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 3.}, {1., 2.}, {-1., 2.}, {-2., 1.}, {2., 
     2.}, {-1., 1.}, {-4., 2.}, {1., 0.}, {0., 1.}, {2., 1.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
 "The ",
 StyleBox["Graph", "Input"],
 " Object"
}], "Subsection",
 CellTags->"Section3c"],

Cell[TextData[{
 "In addition to being able to draw graphs, as described above, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " includes the capability to treat a graph as a raw object. This is the same \
distinction as is made between the plot of a function and the function itself."
}], "Text"],

Cell[TextData[{
 "To create a graph as an object, you use the ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 " function, which is also the head of the object. Just as with ",
 StyleBox[ButtonBox["GraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/GraphPlot"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 ", you can use a list of rules indicating the edges as the input to ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 ". For example, the following defines a ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 " object representing the ",
 StyleBox["div6", "Input"],
 " relation."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"div6G", "=", 
  RowBox[{"Graph", "[", 
   RowBox[{"Rule", "@@@", "div6"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 GraphicsBox[
  NamespaceBox["NetworkGraphics",
   DynamicModuleBox[{Typeset`graph = HoldComplete[
     Graph[{1, 2, 3, 4, 5, 
      6}, {{{1, 1}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {1, 6}, {2, 2}, {2, 4}, {
       2, 6}, {3, 3}, {3, 6}, {4, 4}, {5, 5}, {6, 6}}, Null}]], Typeset`boxes,
     Typeset`boxes$s2d = GraphicsGroupBox[{{
       Arrowheads[0.028937842778793414`], 
       Directive[
        Opacity[0.7], 
        Hue[0.6, 0.7, 0.5]], 
       ArrowBox[{
         DynamicLocation["VertexID$1", Automatic, Center], 
         DynamicLocation["VertexID$2", Automatic, Center]}], 
       ArrowBox[{
         DynamicLocation["VertexID$1", Automatic, Center], 
         DynamicLocation["VertexID$3", Automatic, Center]}], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation[
          "VertexID$1", Automatic, Center], {-0.10455097716174719`, 
          1.8954490228382528`}, {-0.16857303194726453`, 
          1.8314269680527357`}, {-0.24042613086921105`, 
          1.7595738691307892`}, {-0.32011027392758673`, 
          1.6798897260724133`}, {-0.4076254611223915, 
          1.5923745388776085`}, {-0.5029716924536255, 
          1.4970283075463744`}, {-0.6061489679212887, 
          1.3938510320787114`}, {-0.717157287525381, 
          1.282842712474619}, {-0.7765193382916591, 
          1.2185423901034025`}, {-0.8288976183795513, 
          1.1513492952006954`}, {-0.8742921277890583, 
          1.0812634277664974`}, {-0.9127028665201794, 
          1.0082847878008083`}, {-0.9441298345729148, 
          0.9324133753036284}, {-0.9685730319472646, 
          0.8536491902749577}, {-0.9860324586432287, 
          0.771992232714796}, {-0.9965081146608072, 0.6874425026231434}, {-1.,
           0.6}, {-1., 0.5135802469135802}, {-1., 
          0.4320987654320988}, {-1.0000000000000002`, 
          0.35555555555555557`}, {-1., 0.2839506172839506}, {-1., 
          0.2172839506172839}, {-1., 0.15555555555555556`}, {-1., 
          0.09876543209876543}, 
          DynamicLocation["VertexID$4", Automatic, Center]}]], 
       ArrowBox[{
         DynamicLocation["VertexID$1", Automatic, Center], 
         DynamicLocation["VertexID$5", Automatic, Center]}], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation["VertexID$1", Automatic, Center], {
          0.21205113947521276`, 1.8939744302623935`}, {0.34378173048589544`, 
          1.8281091347570524`}, {0.49264900234529563`, 1.7536754988273524`}, {
          0.6586529550534134, 1.6706735224732934`}, {0.8417935886102483, 
          1.5791032056948757`}, {1.042070903015801, 1.4789645484920992`}, {
          1.2594848982700715`, 1.3702575508649641`}, {1.4940355743730591`, 
          1.2529822128134702`}, {1.5952873674058736`, 1.1949489088896552`}, {
          1.6741696684479002`, 1.1332855361464202`}, {1.7306824774991378`, 
          1.0679920945837647`}, {1.7648257945595862`, 0.9990685842016883}, {
          1.7765996196292462`, 0.9265150050001917}, {1.7660039527081177`, 
          0.8503313569792745}, {1.7330387937962004`, 0.7705176401389369}, {
          1.6777041428934947`, 0.6870738544791787}, {1.6, 0.6}, {
          1.5135802469135802`, 0.5135802469135802}, {1.4320987654320987`, 
          0.4320987654320988}, {1.3555555555555558`, 0.35555555555555557`}, {
          1.2839506172839508`, 0.2839506172839506}, {1.217283950617284, 
          0.2172839506172839}, {1.1555555555555554`, 0.15555555555555556`}, {
          1.0987654320987654`, 0.09876543209876543}, 
          DynamicLocation["VertexID$6", Automatic, Center]}]], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation[
          "VertexID$1", Automatic, Center], {-0.28933755257078453`, 
          2.1341854347188893`}, {-0.3748666889890278, 
          2.43579957945292}, {-0.285453852010028, 2.628663380559333}, {
          0.28545385201002776`, 2.628663380559333}, {0.3748666889890277, 
          2.4357995794529206`}, {0.28933755257078453`, 2.1341854347188893`}, 
          DynamicLocation["VertexID$1", Automatic, Center]}, SplineDegree -> 
         7]], 
       ArrowBox[{
         DynamicLocation["VertexID$2", Automatic, Center], 
         DynamicLocation["VertexID$4", Automatic, Center]}], 
       ArrowBox[{
         DynamicLocation["VertexID$2", Automatic, Center], 
         DynamicLocation["VertexID$6", Automatic, Center]}], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation["VertexID$2", Automatic, Center], {
          0.18210546221036392`, 1.430428627189827}, {0.39936740862500514`, 
          1.4993102371676186`}, {0.5476555514121827, 1.4591980431399016`}, {
          0.7119530043698294, 1.0625489039461953`}, {0.6354610574407263, 
          0.9293297482065539}, {0.433127008322802, 0.824409006117316}, 
          DynamicLocation["VertexID$2", Automatic, Center]}, SplineDegree -> 
         7]], 
       ArrowBox[{
         DynamicLocation["VertexID$3", Automatic, Center], 
         DynamicLocation["VertexID$6", Automatic, Center]}], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation["VertexID$3", Automatic, Center], {
          1.0132464889680084`, 1.3186635855386826`}, {1.2591710405119212`, 
          1.5131049402655432`}, {1.4715707702690874`, 1.5043040316232572`}, {
          1.6900476900071553`, 0.9768540889261161}, {1.546081582955237, 
          0.8204416175110697}, {1.2346958644278136`, 0.7840374999245701}, 
          DynamicLocation["VertexID$3", Automatic, Center]}, SplineDegree -> 
         7]], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation[
          "VertexID$4", Automatic, 
           Center], {-0.78403749992457, -0.23469586442781354`}, \
{-0.8204416175110694, -0.546081582955237}, {-0.9768540889261157, \
-0.6900476900071553}, {-1.5043040316232568`, -0.47157077026908745`}, \
{-1.513104940265543, -0.2591710405119212}, {-1.3186635855386823`, \
-0.013246488968008452`}, 
          DynamicLocation["VertexID$4", Automatic, Center]}, SplineDegree -> 
         7]], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation[
          "VertexID$5", Automatic, Center], {-1.99062341425038, 
          0.6811990748789634}, {-2.2221455138730724`, 
          0.4698135435235948}, {-2.434634778051478, 
          0.4635355022074675}, {-2.6899524650649127`, 
          0.9741708762343373}, {-2.5574364735049677`, 
          1.1403954627873851`}, {-2.2494147886470572`, 1.198781823672318}, 
          DynamicLocation["VertexID$5", Automatic, Center]}, SplineDegree -> 
         7]], 
       ArrowBox[
        BezierCurveBox[{
          DynamicLocation["VertexID$6", Automatic, Center], {
          1.2893375525707844`, -0.13418543471888908`}, {
          1.3748666889890278`, -0.43579957945292014`}, {
          1.2854538520100278`, -0.6286633805593327}, {
          0.7145461479899722, -0.6286633805593327}, {
          0.6251333110109722, -0.4357995794529201}, {
          0.7106624474292155, -0.13418543471888908`}, 
          DynamicLocation["VertexID$6", Automatic, Center]}, SplineDegree -> 
         7]]}, {
       Directive[
        Hue[0.6, 0.2, 0.8], 
        EdgeForm[
         Directive[
          GrayLevel[0], 
          Opacity[0.7]]]], 
       TagBox[
        DiskBox[{0., 2.}, 0.030239520958083826`], "DynamicName", BoxID -> 
        "VertexID$1"], 
       TagBox[
        DiskBox[{0., 1.}, 0.030239520958083826`], "DynamicName", BoxID -> 
        "VertexID$2"], 
       TagBox[
        DiskBox[{1., 1.}, 0.030239520958083826`], "DynamicName", BoxID -> 
        "VertexID$3"], 
       TagBox[
        DiskBox[{-1., 0.}, 0.030239520958083826`], "DynamicName", BoxID -> 
        "VertexID$4"], 
       TagBox[
        DiskBox[{-2., 1.}, 0.030239520958083826`], "DynamicName", BoxID -> 
        "VertexID$5"], 
       TagBox[
        DiskBox[{1., 0.}, 0.030239520958083826`], "DynamicName", BoxID -> 
        "VertexID$6"]}}], $CellContext`flag}, 
    TagBox[
     DynamicBox[GraphComputation`NetworkGraphicsBox[
      3, Typeset`graph, Typeset`boxes, $CellContext`flag], {
      CachedValue :> Typeset`boxes, SingleEvaluation -> True, 
       SynchronousUpdating -> False, TrackedSymbols :> {$CellContext`flag}},
      ImageSizeCache->{{3.7606933090100947`, 
       355.2393066909899}, {-135.2393066909899, 128.2393066909899}}],
     MouseAppearanceTag["NetworkGraphics"]],
    AllowKernelInitialization->False,
    UnsavedVariables:>{$CellContext`flag}]],
  DefaultBaseStyle->{
   "NetworkGraphics", FrontEnd`GraphicsHighlightColor -> Hue[0.8, 1., 0.6]},
  FrameTicks->None]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Observe that the output is a plot of the graph. However, ",
 StyleBox["div6G", "Input"],
 " stores a ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 " object, not the plot. The images displayed by ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 " may be very different from those produced by ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 ". The plotting algorithms for ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 " emphasize avoiding edge crossings, while ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " produces images that oftentimes better reveal the structure of a relation. \
Fortunately, ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " will accept a ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 " object as its argument."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"LayeredGraphPlot", "[", 
  RowBox[{"div6G", ",", 
   RowBox[{"VertexLabeling", "\[Rule]", "True"}]}], "]"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[CompressedData["
1:eJx1kWtIk1EYx2firWyCmlqWoYhaRH3IS4n5rygymJN0M0stDLUiLxBJZpol
tfKW2oQwRMmsFplaRLllHFOMylS6zUuJbzPLOdfmNi+b8zWN3heS+nMOD79z
nud8OD/PI+mRSUs4HE7I/F6oi7L9b9TiP5Usmmv5dx/7Dll0vp3hiuVBAbda
JeTanujvo1vn4NFQF9XfJiPcgPaDrVE0sporVnSK28nJV7x4Ufgs/HTXS8Ne
dpFmC7U60NcMXvaxzobsj0RN3bb/SJnw7ajXqnyXfmKTfFoan2WEZiDENcaN
IrZlCYYP+imsCQm6dC1piOgSEp8Hhk/iLJ/To9d9J629uc4ikQExYuEK9I2Q
pAJvvk+uHl0XhTyBaJQMFjtuU5/QQeHFyd5sUpFNQ3u/9vPGUZIqrP3iryaC
gjfBGk8t5InC9ojAn6Taep1YIFdDassZLKJ/kp2VEe5u+1QIPCAcFxdrSNkn
W+66xyPgRwvNiUMaUvRIcOLy3DD7v5t/Z4jlqoeFPUinWO5yKCy/cPczLP6w
a8oLl5QXcvZ+ZaYsABvesyw5OqaY6O5guTxUKQ5VtrFMKeXmxjApy/T6t/lc
KwnSicRs0DXBUrYq5tiWObxxLFXkeHfgAy33bAqnUVl0wOUSR47ULv94DWZx
XnqovuTyIN75+S/lOphh9+p+XIPTMOjln/ycn5ngY1vjbtSMYjLHVWqxy4ir
XLuCyDotmjJnZPJ7U8iwpGv6fAzYTZ/fKB6bwEtFQ2/ZjylUciVOQfYGtNSr
lvFERjT57CB5Hno8sTrslfzahJKMOkutpw61P+xWU40z8JhRUudcxnFFMDYt
DTHjdZr+waFpDZJ51lJ9yjwLnnYsuaNGaPf+uOIdZgRL1rqPBqjAHaAUItkM
Vh/fUOksGUFvxk0e1WNC+vUBfp55GDcqFmIE46e7t11VHTQNxo++zSuJUk6C
8WMT22gV2zgBxo9NVVqnQ6EBjJ+Jovhm+owejJ/3vjnzSwfGz+/28nEwfmIS
+Kf8WrRg/PwCiRew3A==
    "], {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.028937842778793414`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{1, 3}], 
      ArrowBox[{1, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 
       24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 4}], ArrowBox[{1, 5}], 
      ArrowBox[{1, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
        50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 6}], ArrowBox[{2, 4}], 
      ArrowBox[{2, 6}], ArrowBox[{3, 6}]}, {InsetBox[
       FrameBox["1",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["2",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["3",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["4",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["5",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["6",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 2.}, {0., 1.}, {1., 1.}, {-1., 0.}, {-2., 
     1.}, {1., 0.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The main benefit of the ",
 StyleBox[ButtonBox["Graph",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Graph"], "FunctionLink"],
 " object is ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can perform computations with it. For example, we can use this \
representation to determine whether or not the relation is transitive. To do \
this, we use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "'s implementation of the Floyd-Warshall all-pairs shortest path algorithm \
called ",
 StyleBox[ButtonBox["GraphDistanceMatrix",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/GraphDistanceMatrix"], "FunctionLink"],
 ". This function returns a matrix whose ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"i", ",", "j"}], ")"}], TraditionalForm]]],
 " entry represents the shortest path from vertex ",
 Cell[BoxData[
  FormBox["i", TraditionalForm]]],
 " to vertex ",
 Cell[BoxData[
  FormBox["j", TraditionalForm]]],
 ". For example, the distance matrix for the ",
 StyleBox["div6", "Input"],
 " relation is:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"GraphDistanceMatrix", "[", "div6G", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"0", "1", "1", "1", "1", "1"},
     {"\[Infinity]", "0", "\[Infinity]", "1", "\[Infinity]", "1"},
     {"\[Infinity]", "\[Infinity]", "0", "\[Infinity]", "\[Infinity]", "1"},
     {"\[Infinity]", "\[Infinity]", "\[Infinity]", "0", "\[Infinity]", 
      "\[Infinity]"},
     {"\[Infinity]", "\[Infinity]", "\[Infinity]", "\[Infinity]", "0", 
      "\[Infinity]"},
     {"\[Infinity]", "\[Infinity]", "\[Infinity]", "\[Infinity]", 
      "\[Infinity]", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "In a graph of a transitive relation, the distance between any two distinct \
elements must be either 1 or infinite (meaning there is no path between \
them). To see this, assume that you have a transitive relation and suppose \
there are elements ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["Z", TraditionalForm]]],
 " that the all-pairs algorithm has determined have distance 3. That means \
there must be two elements, say ",
 Cell[BoxData[
  FormBox["M", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["N", TraditionalForm]]],
 ", such that ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " is connected to ",
 Cell[BoxData[
  FormBox["M", TraditionalForm]]],
 " is connected to ",
 Cell[BoxData[
  FormBox["N", TraditionalForm]]],
 " is connected to ",
 Cell[BoxData[
  FormBox["Z", TraditionalForm]]],
 ". From the point of view of the relation, then, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"A", ",", "M"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"M", ",", "N"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"N", ",", "Z"}], ")"}], TraditionalForm]]],
 " are all members of the relation. But if the relation is transitive, the \
fact that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"A", ",", "M"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"M", ",", "N"}], ")"}], TraditionalForm]]],
 " are in the relation means that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"A", ",", "N"}], ")"}], TraditionalForm]]],
 " is in the relation. So, ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " to ",
 Cell[BoxData[
  FormBox["N", TraditionalForm]]],
 " to ",
 Cell[BoxData[
  FormBox["Z", TraditionalForm]]],
 " is a shorter path (of length 2). Applying transitivity again shows that ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["Z", TraditionalForm]]],
 " are adjacent. While this does not amount to a proof, it should be \
convincing that we can check for transitivity by making sure that no two \
vertices in the graph of a relation have distance which is finite and greater \
than 1."
}], "Text"],

Cell["Here is the function.", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"transitiveGraphQ", "[", "g_Graph", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"d", ",", "i", ",", "j"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"d", "=", 
      RowBox[{"GraphDistanceMatrix", "[", "g", "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Cases", "[", 
       RowBox[{
        RowBox[{"Flatten", "[", "d", "]"}], ",", 
        RowBox[{"Except", "[", 
         RowBox[{"0", "|", "1", "|", "Infinity"}], "]"}]}], "]"}], "\[Equal]", 
      RowBox[{"{", "}"}]}]}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "After computing the distance matrix, the function uses ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " to identify any elements of the matrix that are not 0, 1, or \[Infinity]. ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " takes a list as the first argument, for which we ",
 StyleBox[ButtonBox["Flatten",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Flatten"], "FunctionLink"],
 " the distance matrix, and a pattern as the second argument. In this case, \
we apply ",
 StyleBox[ButtonBox["Except",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Except"], "FunctionLink"],
 " to 0, 1, and ",
 StyleBox[ButtonBox["Infinity",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Infinity"], "FunctionLink"],
 ", separated by the ",
 StyleBox[ButtonBox["Alternatives",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Alternatives"], "FunctionLink"],
 " (",
 StyleBox["|", "Input"],
 ") operator. This means that anything other than those three symbols will \
match the pattern. The result of ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " will be the list of all the elements of the matrix that are other than 0, \
1, and ",
 StyleBox[ButtonBox["Infinity",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Infinity"], "FunctionLink"],
 ". Consequently, the relation is transitive if and only if that output is \
equal to the empty list."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"transitiveGraphQ", "[", "div6G", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "In this section we have barely scratched the surface of graphs in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". We will return to them in much greater detail in Chapter 10."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["9.4 Closures of Relations", "Section",
 CellTags->"Section4"],

Cell["\<\
In this section, we will develop algorithms to compute the reflexive, \
symmetric, and transitive closures of binary relations. We begin with the \
reflexive closure. \
\>", "Text"],

Cell[CellGroupData[{

Cell["Reflexive Closure", "Subsection",
 PageBreakWithin->False,
 CellTags->"Section4a"],

Cell["\<\
The algorithm for computing the reflexive closure of a relation, with the \
matrix representation, is very simple. We simply set each diagonal entry \
equal to 1. The resulting matrix represents the reflexive closure of the \
relation. \
\>", "Text",
 PageBreakAbove->False,
 PageBreakWithin->False],

Cell[TextData[{
 "Note that this function will accept a matrix as input and return a modified \
version of that matrix. Internally, the function will need to work with a \
copy of the argument. That is, we will need to declare a local variable and \
set it equal to the argument. The reason for this is that when you execute a \
function in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", the argument is immediately substituted for the symbol used to represent \
it everywhere it appears. Thus, if ",
 StyleBox["x", "Input"],
 " is the argument to a function and you call the function with a value of 3, \
an assignment such as ",
 StyleBox["x=5", "Input"],
 " will be interpreted as the illegal assignment ",
 StyleBox["3=5", "Input"],
 "."
}], "Text"],

Cell["\<\
Here is the function for computing the reflexive closure on a matrix \
representation.\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"reflexiveClosure", "[", 
   RowBox[{"m_", "?", "matrix01Q"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"ans", "=", "m"}], ",", "i"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"ans", "[", 
         RowBox[{"[", 
          RowBox[{"i", ",", "i"}], "]"}], "]"}], "=", "1"}], ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", 
         RowBox[{
          RowBox[{"Dimensions", "[", "m", "]"}], "[", 
          RowBox[{"[", "1", "]"}], "]"}]}], "}"}]}], "]"}], ";", 
     "\[IndentingNewLine]", "ans"}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "(Note that all the closure operations only apply to a relation on a set and \
are generally not valid for a relation from one set to a different set. This \
means we may assume that the matrix representation of the relation is square, \
which is imposed by ",
 StyleBox["matrix01Q", "Input"],
 ".)"
}], "Text"],

Cell["\<\
We use this function to find the reflexive closure of the example relation we \
introduced earlier in the chapter.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"reflexiveClosure", "[", "exampleMatrix", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "0", "0"},
     {"0", "1", "1", "0"},
     {"0", "0", "1", "1"},
     {"0", "0", "0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Recall that ",
 StyleBox["exampleMatrix", "Input"],
 " represented the \[OpenCurlyDoubleQuote]is one less than\
\[CloseCurlyDoubleQuote] relation. Looking at the matrix above, you can see \
that the reflexive closure includes equality."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Symmetric Closure", "Subsection",
 CellTags->"Section4b"],

Cell[TextData[{
 "Next we write a function for constructing the symmetric closure of a \
relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ". We use the observation that if ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "b"}], ")"}], TraditionalForm]]],
 " is a member of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " then ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"b", ",", "a"}], ")"}], TraditionalForm]]],
 " must be included in the symmetric closure, so we can simply add it to the \
relation."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"symmetricClosure", "[", 
   RowBox[{"m_", "?", "matrix01Q"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"ans", "=", "m"}], ",", "i", ",", "j"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"ans", "[", 
           RowBox[{"[", 
            RowBox[{"i", ",", "j"}], "]"}], "]"}], "\[Equal]", "1"}], ",", 
         RowBox[{
          RowBox[{"ans", "[", 
           RowBox[{"[", 
            RowBox[{"j", ",", "i"}], "]"}], "]"}], "=", "1"}]}], "]"}], 
       "\[IndentingNewLine]", ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", 
         RowBox[{
          RowBox[{"Dimensions", "[", "m", "]"}], "[", 
          RowBox[{"[", "1", "]"}], "]"}]}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"j", ",", 
         RowBox[{
          RowBox[{"Dimensions", "[", "m", "]"}], "[", 
          RowBox[{"[", "2", "]"}], "]"}]}], "}"}]}], "]"}], ";", 
     "\[IndentingNewLine]", "ans"}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "Applying this to our ",
 StyleBox["exampleMatrix", "Input"],
 " yields the \[OpenCurlyDoubleQuote]different by 1\[CloseCurlyDoubleQuote] \
relation. And applying it to the \[OpenCurlyDoubleQuote]is a divisor of\
\[CloseCurlyDoubleQuote] relation yields the \[OpenCurlyDoubleQuote]is a \
divisor or multiple of\[CloseCurlyDoubleQuote] relation."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"symmetricClosure", "[", "exampleMatrix", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"0", "1", "0", "0"},
     {"1", "0", "1", "0"},
     {"0", "1", "0", "1"},
     {"0", "0", "1", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"symmetricClosure", "[", "div6M", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1", "1", "1", "1"},
     {"1", "1", "0", "1", "0", "1"},
     {"1", "0", "1", "0", "0", "1"},
     {"1", "1", "0", "1", "0", "0"},
     {"1", "0", "0", "0", "1", "0"},
     {"1", "1", "1", "0", "0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Transitive Closure", "Subsection",
 CellTags->"Section4c"],

Cell[TextData[{
 "Having created the reflexive and symmetric closures, we turn to \
implementing the transitive closure in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". This is a more difficult problem than the earlier cases, both in terms of \
computational complexity and implementation. In the text, there are two \
algorithms outlined (a generic transitive closure and Warshall\
\[CloseCurlyQuote]s algorithm) and both will be covered in this section."
}], "Text"],

Cell[CellGroupData[{

Cell["A Transitive Closure Function", "Subsubsection"],

Cell[TextData[{
 "First we will implement the transitive closure algorithm presented as \
Algorithm 1 in Chapter 9 of the text. This will require the Boolean join and \
Boolean product operations on zero-one matrices that were introduced in \
Chapter 2. Recall from Section 2.6 of this manual that the ",
 StyleBox[ButtonBox["BitAnd",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitAnd"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["BitOr",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitOr"], "FunctionLink"],
 " functions correspond to the Boolean operations \[And] and \[Or] . Here are \
some examples."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitAnd", "[", 
  RowBox[{"1", ",", "1"}], "]"}]], "Input"],

Cell[BoxData["1"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitAnd", "[", 
  RowBox[{"1", ",", "0"}], "]"}]], "Input"],

Cell[BoxData["0"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitOr", "[", 
  RowBox[{"0", ",", "1"}], "]"}]], "Input"],

Cell[BoxData["1"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitOr", "[", 
  RowBox[{"1", ",", "1"}], "]"}]], "Input"],

Cell[BoxData["1"], "Output"]
}, Open  ]],

Cell[TextData[{
 "Now we turn to the Boolean join matrix operation. Recall that for zero-one \
matrices ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["B", TraditionalForm]]],
 " of the same size, the join of ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["B", TraditionalForm]]],
 " is the matrix ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Or]", "B"}], TraditionalForm]]],
 " whose ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"i", ",", "j"}], ")"}], TraditionalForm]]],
 " entry is ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["A", 
     RowBox[{"i", " ", "j"}]], "\[Or]", 
    SubscriptBox["B", 
     RowBox[{"i", " ", "j"}]]}], TraditionalForm]]],
 ". Since ",
 StyleBox[ButtonBox["BitOr",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitOr"], "FunctionLink"],
 " automatically threads over lists, it serves the role of the matrix join \
function without any additional work. For example,"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"joinA", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1"}], "}"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"joinA", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "0"},
     {"0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"joinB", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0"}], "}"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"joinB", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1"},
     {"0", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"BitOr", "[", 
   RowBox[{"joinA", ",", "joinB"}], "]"}], "//", "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1"},
     {"0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Next, recall that for appropriately sized zero-one matrices, the Boolean \
product ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[CircleDot]", "B"}], TraditionalForm]]],
 " is the matrix whose ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"i", ",", "j"}], ")"}], TraditionalForm]]],
 " entry is obtained by the formula"
}], "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   UnderoverscriptBox[
    StyleBox["\[Or]",
     FontSize->24], 
    RowBox[{"k", "=", "1"}], "n"], 
   RowBox[{"(", 
    RowBox[{
     SubscriptBox["a", 
      RowBox[{"i", " ", "k"}]], "\[And]", 
     SubscriptBox["b", 
      RowBox[{"k", " ", "j"}]]}], ")"}]}], TraditionalForm]], "Equation"],

Cell[TextData[{
 "where ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " is the number of columns of ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 ", which is also the number of rows of ",
 Cell[BoxData[
  FormBox["B", TraditionalForm]]],
 ". This is implemented in the ",
 StyleBox["boolProduct", "Input"],
 " function. Refer to Section 2.6 where we first developed this function."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"boolProduct", "::", "dimmismatch"}], "=", 
   "\"\<The dimensions of the input matrices do not match.\>\""}], 
  ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"boolProduct", "[", 
   RowBox[{
    RowBox[{"A_", "?", "matrix01Q"}], ",", 
    RowBox[{"B_", "?", "matrix01Q"}]}], "]"}], ":=", "\[IndentingNewLine]", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
     "m", ",", "kA", ",", "kB", ",", "n", ",", "output", ",", "i", ",", "j", 
      ",", "c", ",", "p"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{
      RowBox[{"{", 
       RowBox[{"m", ",", "kA"}], "}"}], "=", 
      RowBox[{"Dimensions", "[", "A", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"kB", ",", "n"}], "}"}], "=", 
      RowBox[{"Dimensions", "[", "B", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"If", "[", 
      RowBox[{
       RowBox[{"kA", "\[NotEqual]", "kB"}], ",", 
       RowBox[{
        RowBox[{"Message", "[", 
         RowBox[{"boolProduct", "::", "dimmismatch"}], "]"}], ";", 
        RowBox[{"Return", "[", "]"}]}]}], "]"}], ";", "\[IndentingNewLine]", 
     RowBox[{"output", "=", 
      RowBox[{"ConstantArray", "[", 
       RowBox[{"0", ",", 
        RowBox[{"{", 
         RowBox[{"m", ",", "n"}], "}"}]}], "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"For", "[", 
      RowBox[{
       RowBox[{"i", "=", "1"}], ",", 
       RowBox[{"i", "\[LessEqual]", "m"}], ",", 
       RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
       RowBox[{"For", "[", 
        RowBox[{
         RowBox[{"j", "=", "1"}], ",", 
         RowBox[{"j", "\[LessEqual]", "n"}], ",", 
         RowBox[{"j", "++"}], ",", "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{"c", "=", 
           RowBox[{"BitAnd", "[", 
            RowBox[{
             RowBox[{"A", "[", 
              RowBox[{"[", 
               RowBox[{"i", ",", "1"}], "]"}], "]"}], ",", 
             RowBox[{"B", "[", 
              RowBox[{"[", 
               RowBox[{"1", ",", "j"}], "]"}], "]"}]}], "]"}]}], ";", 
          "\[IndentingNewLine]", 
          RowBox[{"For", "[", 
           RowBox[{
            RowBox[{"p", "=", "2"}], ",", 
            RowBox[{"p", "\[LessEqual]", "kA"}], ",", 
            RowBox[{"p", "++"}], ",", "\[IndentingNewLine]", 
            RowBox[{
             RowBox[{"c", "=", 
              RowBox[{"BitOr", "[", 
               RowBox[{"c", ",", 
                RowBox[{"BitAnd", "[", 
                 RowBox[{
                  RowBox[{"A", "[", 
                   RowBox[{"[", 
                    RowBox[{"i", ",", "p"}], "]"}], "]"}], ",", 
                  RowBox[{"B", "[", 
                   RowBox[{"[", 
                    RowBox[{"p", ",", "j"}], "]"}], "]"}]}], "]"}]}], "]"}]}],
              ";"}]}], "\[IndentingNewLine]", "]"}], ";", 
          "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"output", "[", 
            RowBox[{"[", 
             RowBox[{"i", ",", "j"}], "]"}], "]"}], "=", "c"}], ";"}]}], 
        "\[IndentingNewLine]", "]"}]}], "\[IndentingNewLine]", "]"}], ";", 
     "\[IndentingNewLine]", "output"}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell["As an example,", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"productA", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "1"}], "}"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"productA", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "0", "1"},
     {"0", "1", "0"},
     {"1", "0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"productB", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "1"}], "}"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"productB", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "0"},
     {"0", "1", "0"},
     {"0", "0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"boolProduct", "[", 
   RowBox[{"productA", ",", "productB"}], "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1"},
     {"0", "1", "0"},
     {"1", "1", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "We are now ready to implement Algorithm 1 from Section 9.4 for calculating \
the transitive closure. Recall that the idea of this algorithm is that we \
compute Boolean powers of the matrix of the relation, up to the size of the \
domain. At each step, we use the Boolean join on ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "=", 
    SuperscriptBox["M", 
     RowBox[{"[", "i", "]"}]]}], TraditionalForm]]],
 " and the result matrix ",
 Cell[BoxData[
  FormBox["B", TraditionalForm]]],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"transitiveClosure", "[", 
   RowBox[{"m_", "?", "matrix01Q"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"i", ",", 
      RowBox[{"a", "=", "m"}], ",", 
      RowBox[{"b", "=", "m"}]}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"a", "=", 
         RowBox[{"boolProduct", "[", 
          RowBox[{"a", ",", "m"}], "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{"b", "=", 
         RowBox[{"BitOr", "[", 
          RowBox[{"b", ",", "a"}], "]"}]}]}], "\[IndentingNewLine]", ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", "2", ",", 
         RowBox[{
          RowBox[{"Dimensions", "[", "m", "]"}], "[", 
          RowBox[{"[", "1", "]"}], "]"}]}], "}"}]}], "]"}], ";", 
     "\[IndentingNewLine]", "b"}]}], "\[IndentingNewLine]", "]"}]}]], "Input",\

 InitializationCell->True],

Cell["\<\
We test our transitive closure function on Example 7 from Section 9.4, where \
it was found that the relation with matrix representation\
\>", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SubscriptBox["M", "R"], "=", 
   RowBox[{"(", "\[NoBreak]", GridBox[{
      {"1", "0", "1"},
      {"0", "1", "0"},
      {"1", "1", "0"}
     }], "\[NoBreak]", ")"}]}], TraditionalForm]], "Equation"],

Cell["has transitive closure", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SubscriptBox["M", 
    SuperscriptBox["R", "*"]], "=", 
   RowBox[{"(", "\[NoBreak]", GridBox[{
      {"1", "1", "1"},
      {"0", "1", "0"},
      {"1", "1", "1"}
     }], "\[NoBreak]", ")"}]}], TraditionalForm]], "Equation"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"example7", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "0"}], "}"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"example7", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "0", "1"},
     {"0", "1", "0"},
     {"1", "1", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"transitiveClosure", "[", "example7", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1"},
     {"0", "1", "0"},
     {"1", "1", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Warshall\[CloseCurlyQuote]s Algorithm", "Subsubsection"],

Cell["\<\
Next we consider Warshall's algorithm, as presented as Algorithm 2 in Section \
9.4. This algorithm is straightforward to implement. \
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"warshall", "[", 
   RowBox[{"m_", "?", "matrix01Q"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"i", ",", "j", ",", "k", ",", 
      RowBox[{"w", "=", "m"}], ",", "n"}], "}"}], ",", "\[IndentingNewLine]", 
    
    RowBox[{
     RowBox[{"n", "=", 
      RowBox[{
       RowBox[{"Dimensions", "[", "m", "]"}], "[", 
       RowBox[{"[", "1", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"For", "[", 
      RowBox[{
       RowBox[{"k", "=", "1"}], ",", 
       RowBox[{"k", "\[LessEqual]", "n"}], ",", 
       RowBox[{"k", "++"}], ",", "\[IndentingNewLine]", 
       RowBox[{"For", "[", 
        RowBox[{
         RowBox[{"i", "=", "1"}], ",", 
         RowBox[{"i", "\[LessEqual]", "n"}], ",", 
         RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
         RowBox[{"For", "[", 
          RowBox[{
           RowBox[{"j", "=", "1"}], ",", 
           RowBox[{"j", "\[LessEqual]", "n"}], ",", 
           RowBox[{"j", "++"}], ",", "\[IndentingNewLine]", 
           RowBox[{
            RowBox[{"w", "[", 
             RowBox[{"[", 
              RowBox[{"i", ",", "j"}], "]"}], "]"}], "=", 
            RowBox[{"BitOr", "[", 
             RowBox[{
              RowBox[{"w", "[", 
               RowBox[{"[", 
                RowBox[{"i", ",", "j"}], "]"}], "]"}], ",", 
              RowBox[{"BitAnd", "[", 
               RowBox[{
                RowBox[{"w", "[", 
                 RowBox[{"[", 
                  RowBox[{"i", ",", "k"}], "]"}], "]"}], ",", 
                RowBox[{"w", "[", 
                 RowBox[{"[", 
                  RowBox[{"k", ",", "j"}], "]"}], "]"}]}], "]"}]}], "]"}]}]}],
           "\[IndentingNewLine]", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
      "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", "w"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell["\<\
Applying this to the same example as before, we see that the result is \
correct.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"warshall", "[", "example7", "]"}], "//", "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1"},
     {"0", "1", "0"},
     {"1", "1", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "We can compare these two functions in terms of execution time using ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "'s ",
 StyleBox[ButtonBox["Timing",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Timing"], "FunctionLink"],
 " function. But we must point out that this comparison for a single example \
does not prove anything about the complexity or relative performance of the \
two algorithms. Rather, it serves as a demonstration that, even for relations \
on small domains, the difference in the computational complexity of the \
algorithms is noticeable. We shall consider the following zero-one matrix \
that represents a relation on the set ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6"}], "}"}], 
   TraditionalForm]]],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"transitiveCompare", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0"}], 
      "}"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"transitiveCompare", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"0", "0", "0", "0", "0", "1"},
     {"1", "0", "1", "0", "0", "0"},
     {"1", "0", "0", "1", "0", "0"},
     {"1", "0", "0", "0", "1", "0"},
     {"1", "0", "0", "0", "0", "1"},
     {"0", "1", "0", "0", "0", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Timing", "[", 
  RowBox[{"warshall", "[", "transitiveCompare", "]"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "0.00096400000000000001312838726619247609`3.0046769471824546", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], 
      "}"}]}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Timing", "[", 
  RowBox[{"transitiveClosure", "[", "transitiveCompare", "]"}], 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"0.00455800000000000041927572524969036749`3.679374234123981", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], "}"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1"}], 
      "}"}]}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
From this example, we can see that Warshall's algorithm can be a substantial \
improvement over the alternative, at least on this specific example. The \
reader is encouraged to explore this further.\
\>", "Text"]
}, Open  ]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["9.5 Equivalence Relations", "Section",
 CellTags->"Section5"],

Cell[TextData[{
 "In this section we will examine how we can use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to compute with equivalence relations. There are three specific problems \
that we will address here: given an equivalence relation on a set, how to \
compute the equivalence class of an element; how to determine the number of \
equivalence relations on a finite set; and how to compute the smallest \
equivalence relation that contains a given relation on some finite set. Note \
that in this section, relations are assumed to be represented as in the start \
of this chapter, as satisfying ",
 StyleBox["relationQ", "Input"],
 "."
}], "Text"],

Cell["\<\
First, we provide a test that determines whether or not a relation is an \
equivalence relation. Using the work that we've already done and recalling \
that an equivalence relation is simply a relation that is reflexive, \
symmetric, and transitive, this task is a simple one.\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"equivalenceQ", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{
   RowBox[{"reflexiveQ", "[", "R", "]"}], "&&", 
   RowBox[{"symmetricQ", "[", "R", "]"}], "&&", 
   RowBox[{"transitiveQ", "[", "R", "]"}]}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "As an example, let's define the equivalence relation \
\[OpenCurlyDoubleQuote]congruent mod 4\[CloseCurlyDoubleQuote] on the \
integers from 0 to ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"makeMod4", "[", "n_Integer", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"i", ",", "j"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Reap", "[", "\[IndentingNewLine]", 
      RowBox[{"Do", "[", 
       RowBox[{
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"Mod", "[", 
            RowBox[{
             RowBox[{"i", "-", "j"}], ",", "4"}], "]"}], "\[Equal]", "0"}], 
          ",", 
          RowBox[{"Sow", "[", 
           RowBox[{"{", 
            RowBox[{"i", ",", "j"}], "}"}], "]"}]}], "]"}], 
        "\[IndentingNewLine]", ",", 
        RowBox[{"{", 
         RowBox[{"i", ",", "0", ",", "n"}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{"j", ",", "0", ",", "n"}], "}"}]}], "]"}], 
      "\[IndentingNewLine]", "]"}], "[", 
     RowBox[{"[", 
      RowBox[{"2", ",", "1"}], "]"}], "]"}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"mod4to8", "=", 
  RowBox[{"makeMod4", "[", "8", "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"0", ",", "0"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"0", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"0", ",", "8"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "7"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "0"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "8"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"7", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"7", ",", "7"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"8", ",", "0"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"8", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"8", ",", "8"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"equivalenceQ", "[", "mod4to8", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Equivalence Classes", "Subsection",
 CellTags->"Section5a"],

Cell[TextData[{
 "Recall that, given an equivalence relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " and a member ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 " of the domain of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ", the equivalence class of ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 " is the set of all members ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]]],
 " of the domain for which the pair ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "b"}], ")"}], TraditionalForm]]],
 " belongs to ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ". In other words, it is the set of all elements in the domain that are ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 "-equivalent to ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 ". So to determine the equivalence class of a particular element of the \
domain, the algorithm is fairly simple. We just search through ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " looking for all pairs of the form ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "b"}], ")"}], TraditionalForm]]],
 ", adding each such second element ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]]],
 " to the class. We do not have to search for pairs of the form ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"b", ",", "a"}], ")"}], TraditionalForm]]],
 " because equivalence relations are symmetric. "
}], "Text"],

Cell[TextData[{
 "We can use the ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " function to implement this approach. Previously, we have used ",
 StyleBox[ButtonBox["Select",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Select"], "FunctionLink"],
 " as a way to compute a sublist based on a criteria. ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " is similar, with two important differences. First, where ",
 StyleBox[ButtonBox["Select",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Select"], "FunctionLink"],
 " uses a function to decide which elements of the original list to include, ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " uses a pattern. For example, to find all of the elements of ",
 StyleBox["mod4to8", "Input"],
 " with first element 3, we would need to match the pattern ",
 StyleBox["{3,_}", "Input"],
 ", as shown below."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Cases", "[", 
  RowBox[{"mod4to8", ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "_"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "7"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The second difference is that ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " can not only list those elements of the original list that match the \
pattern, but it can use a rule so that the output involves a modified version \
of the elements that match the pattern. For example, in order to return only \
the second elements, i.e., the 3 and 7, in the above, we enter the \
following."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Cases", "[", 
  RowBox[{"mod4to8", ",", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"3", ",", "b_"}], "}"}], "\[Rule]", "b"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"3", ",", "7"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The following function returns the equivalence class for a given \
equivalence relation and a point in the domain. We use ",
 StyleBox[ButtonBox["Cases",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Cases"], "FunctionLink"],
 " as illustrated above and apply ",
 StyleBox[ButtonBox["Union",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Union"], "FunctionLink"],
 " to be certain that there are no duplicates in the output and to order the \
result."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"equivalenceClass", "[", 
   RowBox[{
    RowBox[{"R_", "?", "equivalenceQ"}], ",", "a_"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "b", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{"Union", "[", 
     RowBox[{"Cases", "[", 
      RowBox[{"R", ",", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"a", ",", "b_"}], "}"}], "\[Rule]", "b"}]}], "]"}], "]"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "As an example, we compute the equivalence class of 3 in the modulo 4 \
relation on the domain ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "\[Ellipsis]", ",", "30"}], "}"}], 
   TraditionalForm]]],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"equivalenceClass", "[", 
  RowBox[{
   RowBox[{"makeMod4", "[", "30", "]"}], ",", "3"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "3", ",", "7", ",", "11", ",", "15", ",", "19", ",", "23", ",", "27"}], 
  "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Number of Equivalence Relations on a Set", "Subsection",
 CellTags->"Section5b"],

Cell[TextData[{
 "Next, we consider how to construct all of the equivalence relations on a \
given (finite) set. The straightforward way to do this is to construct all \
relations on the given domain and then check them to see if they are \
equivalence relations. Since a relation on a set ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " is merely a subset of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Times]", "A"}], TraditionalForm]]],
 ", generating all relations is the same as generating all subsets of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Times]", "A"}], TraditionalForm]]],
 "."
}], "Text"],

Cell[TextData[{
 "To implement this, we begin by creating the set ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Times]", "A"}], TraditionalForm]]],
 " using ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "\[CloseCurlyQuote]s ",
 StyleBox[ButtonBox["Tuples",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Tuples"], "FunctionLink"],
 " function. ",
 StyleBox[ButtonBox["Tuples",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Tuples"], "FunctionLink"],
 " will take a list and a positive integer, e.g., 2, and return the list of \
all possible tuples of the specified length. In effect, ",
 StyleBox["Tuples[A,2]", "Input"],
 " produces ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Times]", "A"}], TraditionalForm]]],
 ". For example, to compute ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"{", 
     RowBox[{"1", ",", "2"}], "}"}], "\[Times]", 
    RowBox[{"{", 
     RowBox[{"1", ",", "2"}], "}"}]}], TraditionalForm]]],
 ", we would enter the following."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Tuples", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", "2"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "We apply the ",
 StyleBox[ButtonBox["Subsets",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Subsets"], "FunctionLink"],
 " function to ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Times]", "A"}], TraditionalForm]]],
 " in order to find all subsets. Given a list, ",
 StyleBox[ButtonBox["Subsets",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Subsets"], "FunctionLink"],
 " produces the list of all sublists. For example, applying ",
 StyleBox[ButtonBox["Subsets",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Subsets"], "FunctionLink"],
 " to the output from ",
 StyleBox[ButtonBox["Tuples",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Tuples"], "FunctionLink"],
 " above produces the following."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Subsets", "[", 
  RowBox[{"Tuples", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"1", ",", "2"}], "}"}], ",", "2"}], "]"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"{", 
     RowBox[{"1", ",", "1"}], "}"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"{", 
     RowBox[{"1", ",", "2"}], "}"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"{", 
     RowBox[{"2", ",", "1"}], "}"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"{", 
     RowBox[{"2", ",", "2"}], "}"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["Column",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Column"], "FunctionLink"],
 " function will place each element of the output from ",
 StyleBox[ButtonBox["Subsets",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Subsets"], "FunctionLink"],
 " on a separate line, so as to make it easier to read."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Column", "[", "%", "]"}]], "Input"],

Cell[BoxData[
 TagBox[GridBox[{
    {
     RowBox[{"{", "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"1", ",", "1"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"1", ",", "2"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"2", ",", "1"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"2", ",", "2"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]}
   },
   DefaultBaseStyle->"Column",
   GridBoxAlignment->{"Columns" -> {{Left}}},
   GridBoxItemSize->{"Columns" -> {{Automatic}}, "Rows" -> {{Automatic}}}],
  "Column"]], "Output"]
}, Open  ]],

Cell[TextData[{
 "To complete the process, we need to limit the output to those subsets of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Times]", "A"}], TraditionalForm]]],
 " which are equivalence relations. For this, we will apply ",
 StyleBox[ButtonBox["Select",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Select"], "FunctionLink"],
 ". Recall that ",
 StyleBox[ButtonBox["Select",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Select"], "FunctionLink"],
 " applied to a list and a function will produce the sublist of the original \
for which the function returns ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 ". In this case, the function we use will be ",
 StyleBox["equivalenceQ", "Input"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Select", "[", 
   RowBox[{
    RowBox[{"Subsets", "[", 
     RowBox[{"Tuples", "[", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", "2"}], "]"}], "]"}], ",", 
    "equivalenceQ"}], "]"}], "//", "Column"}]], "Input"],

Cell[BoxData[
 TagBox[GridBox[{
    {
     RowBox[{"{", "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"1", ",", "1"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"2", ",", "2"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]}
   },
   DefaultBaseStyle->"Column",
   GridBoxAlignment->{"Columns" -> {{Left}}},
   GridBoxItemSize->{"Columns" -> {{Automatic}}, "Rows" -> {{Automatic}}}],
  "Column"]], "Output"]
}, Open  ]],

Cell[TextData[{
 "This example shows us how to build a more general function. ",
 StyleBox["allEquivalenceRelations", "Input"],
 " below will accept a list as its argument and will output all of the \
equivalence relations."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"allEquivalenceRelations", "[", "A_List", "]"}], ":=", 
  RowBox[{"Select", "[", 
   RowBox[{
    RowBox[{"Subsets", "[", 
     RowBox[{"Tuples", "[", 
      RowBox[{"A", ",", "2"}], "]"}], "]"}], ",", "equivalenceQ"}], 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "For example, there are 15 equivalence relations on ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], TraditionalForm]]],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Length", "[", 
  RowBox[{"allEquivalenceRelations", "[", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], "]"}], "]"}]], "Input"],

Cell[BoxData["15"], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Closure", "Subsection",
 CellTags->"Section5c"],

Cell[TextData[{
 "The last question to be considered in this section is the problem of \
finding the smallest equivalence relation containing a relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 "."
}], "Text"],

Cell[TextData[{
 "The key idea is that we need to find the smallest relation containing ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " that is reflexive, symmetric, and transitive. Recalling the previous \
section on closures, it is natural to think that we may compute the reflexive \
closure, the symmetric closure, and then the transitive closure, one after \
the other. The only concern would be that one closure would no longer have \
one of the previous properties. The following outlines why this is not the \
case."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
 "First create the reflexive closure of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ", call it ",
 Cell[BoxData[
  FormBox["P", TraditionalForm]]],
 "."
}], "Item1Numbered"],

Cell[TextData[{
 "Compute the symmetric closure of ",
 Cell[BoxData[
  FormBox["P", TraditionalForm]]],
 " and call this ",
 Cell[BoxData[
  FormBox["Q", TraditionalForm]]],
 ". Note that ",
 Cell[BoxData[
  FormBox["Q", TraditionalForm]]],
 " is still reflexive since no pairs were removed from the relation and no \
elements were added to the domain. So ",
 Cell[BoxData[
  FormBox["Q", TraditionalForm]]],
 " is both symmetric and reflexive."
}], "Item1Numbered"],

Cell[TextData[{
 "Compute the transitive closure of ",
 Cell[BoxData[
  FormBox["Q", TraditionalForm]]],
 " and name this ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 ". Note that ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " is still reflexive for the same reason as above. And ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " is still symmetric since, if ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "b"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"b", ",", "c"}], ")"}], TraditionalForm]]],
 " are in ",
 Cell[BoxData[
  FormBox["Q", TraditionalForm]]],
 " to force the addition of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "c"}], ")"}], TraditionalForm]]],
 ", then since ",
 Cell[BoxData[
  FormBox["Q", TraditionalForm]]],
 " is symmetric, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"c", ",", "b"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"b", ",", "a"}], ")"}], TraditionalForm]]],
 " must also be in ",
 Cell[BoxData[
  FormBox["Q", TraditionalForm]]],
 " forcing ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"c", ",", "a"}], ")"}], TraditionalForm]]],
 " to also be included in ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 ". Hence, ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " is an equivalence relation."
}], "Item1Numbered"]
}, Open  ]],

Cell[TextData[{
 "We implement this method as the composition of the four methods ",
 StyleBox["relationToMatrix", "Input"],
 ", ",
 StyleBox["reflexiveClosure", "Input"],
 ", ",
 StyleBox["symmetricClosure", "Input"],
 ", and then ",
 StyleBox["transitiveClosure", "Input"],
 ". "
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"equivalenceClosure", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{"transitiveClosure", "[", 
   RowBox[{"symmetricClosure", "[", 
    RowBox[{"reflexiveClosure", "[", 
     RowBox[{"relationToMatrix", "[", "R", "]"}], "]"}], "]"}], 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "As an example, recall the ",
 StyleBox["div6", "Input"],
 " relation representing the is a divisor of on ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6"}], "}"}], 
   TraditionalForm]]],
 ". We can see that the smallest equivalence relation that contains ",
 StyleBox["div6", "Input"],
 " is the relation in which every number is related to every other number."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"equivalenceClosure", "[", "div6", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1", "1", "1", "1"},
     {"1", "1", "1", "1", "1", "1"},
     {"1", "1", "1", "1", "1", "1"},
     {"1", "1", "1", "1", "1", "1"},
     {"1", "1", "1", "1", "1", "1"},
     {"1", "1", "1", "1", "1", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell["\<\
This is unsurprising, since 1 is a divisor of every number meaning that, in \
any equivalence relation containing the \[OpenCurlyDoubleQuote]divides\
\[CloseCurlyDoubleQuote] relation, 1 is related to every number. We can make \
this example slightly more interesting by removing 1.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"div17minus1", "=", 
  RowBox[{"dividesRelation", "[", 
   RowBox[{"Range", "[", 
    RowBox[{"2", ",", "17"}], "]"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "8"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "12"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "14"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "16"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "9"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "12"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "15"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "8"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "12"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "16"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "15"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "12"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"7", ",", "7"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"7", ",", "14"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"8", ",", "8"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"8", ",", "16"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"9", ",", "9"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"10", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"11", ",", "11"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"12", ",", "12"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"13", ",", "13"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"14", ",", "14"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"15", ",", "15"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"16", ",", "16"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"17", ",", "17"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"equivalenceClosure", "[", "div17minus1", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", 
      "0", "0", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "0", 
      "0", "0", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "0", 
      "0", "0", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", 
      "1", "1", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", 
      "0", "0", "1"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "(Note the first row and column still correspond to 1 because of the way the \
matrix is constructed in ",
 StyleBox["relationToMatrix", "Input"],
 ".) In this example, you see that 11, 13, and 17 become isolated, being the \
three primes in the set which do not have multiples of them also included."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["9.6 Partial Orderings", "Section",
 CellTags->"Section6"],

Cell[TextData[{
 "In this section, we consider partial orderings (or partial orders) and \
related topics, including maximal and minimal elements, Hasse diagrams, and \
lattices. We will explore these topics in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", and leave the exploration of other topics related to partial orderings to \
the reader."
}], "Text"],

Cell[CellGroupData[{

Cell["Partial Orders and Examples", "Subsection",
 CellTags->"Section6a"],

Cell[TextData[{
 "First, we will define a new ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " predicate for partial orders and create some examples of them."
}], "Text"],

Cell[TextData[{
 "Recall that a partial order is a binary relation on a set that satisfies \
the three conditions of being reflexive, antisymmetric, and transitive. We \
define the predicate to be a function that tests an object against the \
definition of a partial order. It is very similar to the ",
 StyleBox["equivalenceQ", "Input"],
 " function we created in the previous section."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"partialOrderQ", "[", 
   RowBox[{"R_", "?", "relationQ"}], "]"}], ":=", 
  RowBox[{
   RowBox[{"reflexiveQ", "[", "R", "]"}], "&&", 
   RowBox[{"antisymmetricQ", "[", "R", "]"}], "&&", 
   RowBox[{"transitiveQ", "[", "R", "]"}]}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "Now we can use the ",
 StyleBox["partialOrderQ", "Input"],
 " function for checking to see if a list is a partial order. For example, we \
can check that the ",
 StyleBox["div6", "Input"],
 " relation we defined earlier (recall that this is the \
\[OpenCurlyDoubleQuote]divides\[CloseCurlyDoubleQuote] relation on the set 1 \
through 6) is a partial order."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"partialOrderQ", "[", "div6", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "We create some additional examples of partial orderings that we can use in \
the remainder of the section. The ",
 StyleBox["div17minus1", "Input"],
 " relation (this was the \[OpenCurlyDoubleQuote]divides\
\[CloseCurlyDoubleQuote] relation on the set 2 through 17) is a partial order."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"partialOrderQ", "[", "div17minus1", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[TextData[{
 "Indeed, all the relations created via the ",
 StyleBox["dividesRelation", "Input"],
 " function will be partial orders."
}], "Text"],

Cell[TextData[{
 "Next, we create a function to produce examples of a class of lattices (we \
will discuss lattices more below, for now it is enough that these examples \
are partial orders). The ",
 StyleBox["divisorLattice", "Input"],
 " function will create the partial order whose domain is the set of positive \
divisors of a given number and whose order is defined by the \
\[OpenCurlyDoubleQuote]divides\[CloseCurlyDoubleQuote] relation. We only need \
to apply the ",
 StyleBox["dividesRelation", "Input"],
 " function to the divisors of the given number."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"divisorLattice", "[", "n_Integer", "]"}], ":=", 
  RowBox[{"dividesRelation", "[", 
   RowBox[{"Divisors", "[", "n", "]"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["Divisors",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Divisors"], "FunctionLink"],
 " function produces the list of positive divisors of the given integer."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"divisorLattice", "[", "10", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"10", ",", "10"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
Finally, for a bit of variety, we create the posets whose Hasse diagrams are \
shown in Figure 8(a) and Figure 10 in Section 9.6. \
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"fig8A", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"\"\<a\>\"", ",", "\"\<a\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<a\>\"", ",", "\"\<b\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<a\>\"", ",", "\"\<c\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<a\>\"", ",", "\"\<d\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<a\>\"", ",", "\"\<e\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<a\>\"", ",", "\"\<f\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<b\>\"", ",", "\"\<b\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<b\>\"", ",", "\"\<c\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<b\>\"", ",", "\"\<d\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<b\>\"", ",", "\"\<e\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<b\>\"", ",", "\"\<f\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<c\>\"", ",", "\"\<c\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<c\>\"", ",", "\"\<e\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<c\>\"", ",", "\"\<f\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<d\>\"", ",", "\"\<d\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<d\>\"", ",", "\"\<e\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<d\>\"", ",", "\"\<f\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<e\>\"", ",", "\"\<e\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<e\>\"", ",", "\"\<f\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<f\>\"", ",", "\"\<f\>\""}], "}"}]}], "}"}]}], 
  ";"}]], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"partialOrderQ", "[", "fig8A", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[BoxData[
 RowBox[{
  RowBox[{"fig10", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"\"\<A\>\"", ",", "\"\<A\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<A\>\"", ",", "\"\<B\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<A\>\"", ",", "\"\<D\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<A\>\"", ",", "\"\<F\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<A\>\"", ",", "\"\<G\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<B\>\"", ",", "\"\<B\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<B\>\"", ",", "\"\<D\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<B\>\"", ",", "\"\<F\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<B\>\"", ",", "\"\<G\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<C\>\"", ",", "\"\<C\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<C\>\"", ",", "\"\<B\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<C\>\"", ",", "\"\<D\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<C\>\"", ",", "\"\<F\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<C\>\"", ",", "\"\<G\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<D\>\"", ",", "\"\<D\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<D\>\"", ",", "\"\<G\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<E\>\"", ",", "\"\<E\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<E\>\"", ",", "\"\<F\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<E\>\"", ",", "\"\<G\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<F\>\"", ",", "\"\<F\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<F\>\"", ",", "\"\<G\>\""}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\"\<G\>\"", ",", "\"\<G\>\""}], "}"}]}], "}"}]}], 
  ";"}]], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"partialOrderQ", "[", "fig10", "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Hasse Diagrams", "Subsection",
 CellTags->"Section6b"],

Cell[TextData[{
 "Now that we have defined a predicate and have examples at our disposal, we \
turn to the problem of having ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " draw Hasse diagrams of partial orders. As demonstrated in the textbook, a \
Hasse diagram is a very useful tool for visualizing and understanding posets. \
Drawing the Hasse diagram for a poset is not as simple as drawing all of the \
elements of the set and then connecting all related pairs with an edge. Doing \
so would create an extremely messy, and not very useful, diagram. Instead, a \
Hasse diagram contains only those edges that are absolutely necessary to \
reveal the structure of the poset."
}], "Text"],

Cell[CellGroupData[{

Cell["Covering Relations", "Subsubsection"],

Cell["\<\
The covering relation for a partial order is a minimal representation of the \
partial order, from which the partial order can be reconstructed via \
transitive and reflexive closure. \
\>", "Text"],

Cell[TextData[{
 "Let \[PrecedesSlantEqual] be a partial order on a set ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 ". Recall that an element ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 " in ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " ",
 StyleBox["covers",
  FontSlant->"Italic"],
 " an element ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 " in ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " if ",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", "\[Precedes]", "y"}], TraditionalForm]]],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", "\[NotEqual]", "y"}], TraditionalForm]]],
 ", and there is no element ",
 Cell[BoxData[
  FormBox["z", TraditionalForm]]],
 " of ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 ", different from ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 ", such that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", "\[Precedes]", "z", "\[Precedes]", "y"}], TraditionalForm]]],
 ". In other words, ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 " covers ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 " if ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 " is greater than ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 " and there is no intermediary element. The set of pairs ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"x", ",", "y"}], ")"}], TraditionalForm]]],
 " for which ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 " covers ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 " is the covering relation of ",
 "\[PrecedesSlantEqual]",
 "."
}], "Text"],

Cell[TextData[{
 "As a simple example, consider the set ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4"}], "}"}], TraditionalForm]]],
 " ordered by magnitude, i.e., the usual \[OpenCurlyDoubleQuote]less than or \
equal to.\[CloseCurlyDoubleQuote] This relation consists of 10 ordered \
pairs:"
}], "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{"{", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{"1", ",", "1"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"1", ",", "2"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"1", ",", "3"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"1", ",", "4"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"2", ",", "2"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"2", ",", "3"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"2", ",", "4"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"3", ",", "3"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"3", ",", "4"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"4", ",", "4"}], ")"}]}], "}"}], TraditionalForm]], "Equation"],

Cell["Its covering relation is the set ", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{"{", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{"1", ",", "2"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"2", ",", "3"}], ")"}], ",", 
    RowBox[{"(", 
     RowBox[{"3", ",", "4"}], ")"}]}], "}"}], TraditionalForm]], "Equation"],

Cell[TextData[{
 "which consists of only 3 pairs. All the other pairs of the partial order \
can be inferred from the covering relation using transitivity and \
reflexivity. For instance, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"1", ",", "3"}], ")"}], TraditionalForm]]],
 " can be recovered from ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"1", ",", "2"}], ")"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"2", ",", "3"}], ")"}], TraditionalForm]]],
 " via transitivity. Note that the covering relation involves many fewer \
pairs and thus is a much more efficient way to represent the partial order, \
at least in terms of storage."
}], "Text"],

Cell[TextData[{
 "Our goal is to write a function that will have ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " draw the Hasse diagram of a given partial order. Since a Hasse diagram is, \
in fact, the graph of the associated covering relation, we will create a \
function to find the covering relation of the partial order."
}], "Text"],

Cell["\<\
First, we need a test to check whether a given element covers another. \
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"coversQ", "[", 
   RowBox[{
    RowBox[{"R_", "?", "partialOrderQ"}], ",", 
    RowBox[{"{", 
     RowBox[{"x_", ",", "y_"}], "}"}]}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"z", ",", "checkSet"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{"Catch", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{"x", "\[Equal]", "y"}], ",", 
        RowBox[{"Throw", "[", "False", "]"}]}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{"!", 
         RowBox[{"MemberQ", "[", 
          RowBox[{"R", ",", 
           RowBox[{"{", 
            RowBox[{"x", ",", "y"}], "}"}]}], "]"}]}], ",", 
        RowBox[{"Throw", "[", "False", "]"}]}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"checkSet", "=", 
       RowBox[{"Complement", "[", 
        RowBox[{
         RowBox[{"findDomain", "[", "R", "]"}], ",", 
         RowBox[{"{", 
          RowBox[{"x", ",", "y"}], "}"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"Do", "[", 
       RowBox[{
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"MemberQ", "[", 
            RowBox[{"R", ",", 
             RowBox[{"{", 
              RowBox[{"x", ",", "z"}], "}"}]}], "]"}], "&&", 
           RowBox[{"MemberQ", "[", 
            RowBox[{"R", ",", 
             RowBox[{"{", 
              RowBox[{"z", ",", "y"}], "}"}]}], "]"}]}], ",", 
          RowBox[{"Throw", "[", "False", "]"}]}], "]"}], 
        "\[IndentingNewLine]", ",", 
        RowBox[{"{", 
         RowBox[{"z", ",", "checkSet"}], "}"}]}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "This function works by first checking to see if the two elements ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 " are equal to each other or if the pair ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"x", ",", "y"}], ")"}], TraditionalForm]]],
 " fails to be in the partial order. In either of these situations, ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 " does not cover ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 ". Assuming the pair of elements passes these basic hurdles, the function \
then checks every other element of the domain. If it can find an element that \
sits between ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 ", then we know they don't cover. If no element sits between them, then in \
fact ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]]],
 " does cover ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]]],
 "."
}], "Text"],

Cell[TextData[{
 "Now we can construct the covering relation of a partial order using the \
following ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " function. This function simply checks every element of the given relation \
to see if one covers the other and includes only those that do in the output \
relation. It uses ",
 StyleBox[ButtonBox["Select",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Select"], "FunctionLink"],
 " to execute the check over each element of the given relation and eliminate \
those that do not belong. The test used is a pure ",
 StyleBox[ButtonBox["Function",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Function"], "FunctionLink"],
 " (",
 StyleBox["&", "Input"],
 ") formed from ",
 StyleBox["coversQ", "Input"],
 ". "
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"coveringRelation", "[", 
   RowBox[{"R_", "?", "partialOrderQ"}], "]"}], ":=", 
  RowBox[{"Select", "[", 
   RowBox[{"R", ",", 
    RowBox[{
     RowBox[{"coversQ", "[", 
      RowBox[{"R", ",", "#"}], "]"}], "&"}]}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "Let's look at a couple of examples. First, the example described above, of \
the set ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4"}], "}"}], TraditionalForm]]],
 " ordered by magnitude."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"coveringRelation", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"1", ",", "1"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"1", ",", "2"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"1", ",", "4"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"2", ",", "2"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"2", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"2", ",", "4"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"3", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"3", ",", "4"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"4", ",", "4"}], "}"}]}], "}"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "4"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
As a second example, let\[CloseCurlyQuote]s consider a lattice.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"coveringRelation", "[", 
  RowBox[{"divisorLattice", "[", "30", "]"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "15"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "10"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "15"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"6", ",", "30"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"10", ",", "30"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"15", ",", "30"}], "}"}]}], "}"}]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Drawing Hasse Diagrams", "Subsubsection"],

Cell[TextData[{
 "Now we will use the covering relation in order to write a function to draw \
the Hasse diagram for partial orders. By using the ",
 StyleBox["coveringRelation", "Input"],
 " function that we just completed and the ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " function, we can draw the graph associated to a partial order. "
}], "Text"],

Cell[TextData[{
 "Because ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " draws graphs with arrows pointing downwards, we interpret ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"a", ",", "b"}], "}"}], TraditionalForm]]],
 " as an edge ",
 Cell[BoxData[
  FormBox[
   RowBox[{"b", "\[Rule]", "a"}], TraditionalForm]]],
 " in order to have the smallest elements at the bottom, as is typical. We \
accomplish that by applying ",
 StyleBox[ButtonBox["ReplaceAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ReplaceAll"], "FunctionLink"],
 " (",
 StyleBox["/.", "Input"],
 ") to the covering relation, which remember is represented as a list of \
pairs, transforming a pair into the rule in the reverse order."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"hasseDiagram", "[", 
   RowBox[{"R_", "?", "partialOrderQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "edges", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"edges", "=", 
      RowBox[{
       RowBox[{"coveringRelation", "[", "R", "]"}], "/.", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"a_", ",", "b_"}], "}"}], "\[Rule]", 
        RowBox[{"Rule", "[", 
         RowBox[{"b", ",", "a"}], "]"}]}]}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"LayeredGraphPlot", "[", 
      RowBox[{"edges", ",", 
       RowBox[{"VertexLabeling", "\[Rule]", "True"}]}], "]"}]}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell["\<\
As an example, here is a diagram representing the divisor lattice of 210. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"hasseDiagram", "[", 
  RowBox[{"divisorLattice", "[", 
   RowBox[{"2", "*", "3", "*", "5", "*", "7"}], "]"}], "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[{{0., 1.}, {1., 0.}, {1., 1.}, {2., 1.}, {3., 
    1.}, {-1., 2.}, {0., 2.}, {1., 2.}, {2., 2.}, {3., 2.}, {4., 2.}, {0., 
    3.}, {1., 3.}, {2., 3.}, {3., 3.}, {2., 4.}}, {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.023064257028112448`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{3, 2}], ArrowBox[{4, 2}], ArrowBox[{5, 2}], 
      ArrowBox[{6, 1}], ArrowBox[{6, 3}], ArrowBox[{7, 1}], ArrowBox[{7, 4}], 
      ArrowBox[{8, 1}], ArrowBox[{8, 5}], ArrowBox[{9, 3}], ArrowBox[{9, 4}], 
      ArrowBox[{10, 3}], ArrowBox[{10, 5}], ArrowBox[{11, 4}], 
      ArrowBox[{11, 5}], ArrowBox[{12, 6}], ArrowBox[{12, 7}], 
      ArrowBox[{12, 9}], ArrowBox[{13, 6}], ArrowBox[{13, 8}], 
      ArrowBox[{13, 10}], ArrowBox[{14, 7}], ArrowBox[{14, 8}], 
      ArrowBox[{14, 11}], ArrowBox[{15, 9}], ArrowBox[{15, 10}], 
      ArrowBox[{15, 11}], ArrowBox[{16, 12}], ArrowBox[{16, 13}], 
      ArrowBox[{16, 14}], ArrowBox[{16, 15}]}, {InsetBox[
       FrameBox["2",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["1",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["3",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["5",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["7",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["6",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6], InsetBox[
       FrameBox["10",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 7], InsetBox[
       FrameBox["14",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 8], InsetBox[
       FrameBox["15",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 9], InsetBox[
       FrameBox["21",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 10], InsetBox[
       FrameBox["35",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 11], InsetBox[
       FrameBox["30",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 12], InsetBox[
       FrameBox["42",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 13], InsetBox[
       FrameBox["70",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 14], InsetBox[
       FrameBox["105",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 15], InsetBox[
       FrameBox["210",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 16]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 1.}, {1., 0.}, {1., 1.}, {2., 1.}, {3., 
     1.}, {-1., 2.}, {0., 2.}, {1., 2.}, {2., 2.}, {3., 2.}, {4., 2.}, {0., 
     3.}, {1., 3.}, {2., 3.}, {3., 3.}, {2., 4.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell["\<\
And here are the Hasse diagrams for some of the other examples we discussed \
in this section.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"hasseDiagram", "[", "fig8A", "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[{{0., 1.}, {0., 0.}, {0., 2.}, {1., 2.}, {0., 
    3.}, {0., 4.}}, {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.02554714064914992, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{3, 1}], ArrowBox[{4, 1}], ArrowBox[{5, 3}], 
      ArrowBox[{5, 4}], ArrowBox[{6, 5}]}, {InsetBox[
       FrameBox["\<\"b\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["\<\"a\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["\<\"c\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["\<\"d\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["\<\"e\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["\<\"f\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 1.}, {0., 0.}, {0., 2.}, {1., 2.}, {0., 
     3.}, {0., 4.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"hasseDiagram", "[", "div17minus1", "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[{{0., 1.}, {0., 0.}, {1., 1.}, {-3., 1.}, {-1., 
    1.}, {1., 0.}, {2., 1.}, {-2., 1.}, {0., 2.}, {1., 2.}, {-3., 0.}, {-1., 
    0.}, {0., 3.}}, {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.023064257028112448`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{3, 2}], ArrowBox[{3, 6}], ArrowBox[{4, 2}], 
      ArrowBox[{4, 11}], ArrowBox[{5, 2}], ArrowBox[{5, 12}], 
      ArrowBox[{7, 6}], ArrowBox[{8, 6}], ArrowBox[{8, 11}], ArrowBox[{9, 1}],
       ArrowBox[{10, 1}], ArrowBox[{10, 3}], ArrowBox[{13, 9}]}, {InsetBox[
       FrameBox["4",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["2",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["6",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["10",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["14",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["3",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6], InsetBox[
       FrameBox["9",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 7], InsetBox[
       FrameBox["15",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 8], InsetBox[
       FrameBox["8",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 9], InsetBox[
       FrameBox["12",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 10], InsetBox[
       FrameBox["5",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 11], InsetBox[
       FrameBox["7",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 12], InsetBox[
       FrameBox["16",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 13]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 1.}, {0., 0.}, {1., 1.}, {-3., 1.}, {-1., 
     1.}, {1., 0.}, {2., 1.}, {-2., 1.}, {0., 2.}, {1., 2.}, {-3., 0.}, {-1., 
     0.}, {0., 3.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"hasseDiagram", "[", "fig10", "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[{{0., 1.}, {0., 0.}, {0., 2.}, {-1., 2.}, {1., 
    0.}, {-1., 3.}, {-1., 1.}}, {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.028937842778793414`, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{1, 5}], ArrowBox[{3, 1}], ArrowBox[{4, 1}], 
      ArrowBox[{4, 7}], ArrowBox[{6, 3}], ArrowBox[{6, 4}]}, {InsetBox[
       FrameBox["\<\"B\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["\<\"A\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["\<\"D\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["\<\"F\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["\<\"C\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["\<\"G\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6], InsetBox[
       FrameBox["\<\"E\"\>",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 7]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 1.}, {0., 0.}, {0., 2.}, {-1., 2.}, {1., 
     0.}, {-1., 3.}, {-1., 1.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Comparing this last example to the diagram given in the textbook \
illustrates that, while using ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "'s ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " function doesn't result in quite as appealing graphs as those that are \
created by hand, it still provides a fairly useful graph. Also note that you \
can tweak the results of ",
 StyleBox[ButtonBox["LayeredGraphPlot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/LayeredGraphPlot"], "FunctionLink"],
 " dynamically. To adjust the location of a vertex, place the mouse pointer \
over the vertex, double-click to enter editing mode for the graph, and \
double-click again to edit the vertex. Then you can click and drag the vertex \
to specify a different position. "
}], "Text"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Maximal and Minimal Elements", "Subsection",
 CellTags->"Section6c"],

Cell["\<\
We will construct a function that determines the set of minimal elements of a \
partially ordered set.\
\>", "Text"],

Cell[TextData[{
 "The function takes two arguments: a partial order ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " and a subset ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " of the domain of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ". It returns the set of minimal elements of ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " with respect to ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ". It first initializes the set of minimal elements to all of ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " and then removes those that are not minimal."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"minimalElements", "[", 
   RowBox[{
    RowBox[{"R_", "?", "partialOrderQ"}], ",", "S_List"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"M", ",", "s", ",", "t"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"M", "=", "S"}], ";", "\[IndentingNewLine]", 
     RowBox[{"Do", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"Do", "[", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{"MemberQ", "[", 
            RowBox[{"R", ",", 
             RowBox[{"{", 
              RowBox[{"t", ",", "s"}], "}"}]}], "]"}], ",", 
           RowBox[{"M", "=", 
            RowBox[{"Complement", "[", 
             RowBox[{"M", ",", 
              RowBox[{"{", "s", "}"}]}], "]"}]}]}], "]"}], 
         "\[IndentingNewLine]", ",", 
         RowBox[{"{", 
          RowBox[{"t", ",", 
           RowBox[{"Complement", "[", 
            RowBox[{"S", ",", 
             RowBox[{"{", "s", "}"}]}], "]"}]}], "}"}]}], "]"}], 
       "\[IndentingNewLine]", ",", 
       RowBox[{"{", 
        RowBox[{"s", ",", "S"}], "}"}]}], "]"}], ";", "\[IndentingNewLine]", 
     "M"}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "We can see this work on our ",
 StyleBox["div6", "Input"],
 " partial order. Since we'll be using the ",
 StyleBox["div6", "Input"],
 " partial order for many examples in this section, it's Hasse diagram may \
also be useful."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"hasseDiagram", "[", "div6", "]"}]], "Input"],

Cell[BoxData[
 GraphicsBox[
  TagBox[GraphicsComplexBox[{{0., 1.}, {0., 0.}, {1., 1.}, {-1., 1.}, {0., 
    2.}, {1., 2.}}, {
     {RGBColor[0.5, 0., 0.], Arrowheads[{{0.03384563758389261, 0.7}}], 
      ArrowBox[{1, 2}], ArrowBox[{3, 2}], ArrowBox[{4, 2}], ArrowBox[{5, 1}], 
      ArrowBox[{6, 1}], ArrowBox[{6, 3}]}, {InsetBox[
       FrameBox["2",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 1], InsetBox[
       FrameBox["1",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 2], InsetBox[
       FrameBox["3",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 3], InsetBox[
       FrameBox["5",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 4], InsetBox[
       FrameBox["4",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 5], InsetBox[
       FrameBox["6",
        Background->RGBColor[1, 1, 0.8],
        FrameStyle->RGBColor[0.94, 0.85, 0.36],
        StripOnInput->False], 6]}}],
   Annotation[#, 
    VertexCoordinateRules -> {{0., 1.}, {0., 0.}, {1., 1.}, {-1., 1.}, {0., 
     2.}, {1., 2.}}]& ],
  AspectRatio->Automatic,
  FrameTicks->None,
  PlotRange->All,
  PlotRangePadding->Scaled[0.1]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"minimalElements", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"Range", "[", "6", "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", "1", "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"minimalElements", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"Range", "[", 
    RowBox[{"2", ",", "6"}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"2", ",", "3", ",", "5"}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
Note that, by reversing the relation and thus the order, we can compute \
maximal elements very easily.\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"maximalElements", "[", 
   RowBox[{
    RowBox[{"R_", "?", "partialOrderQ"}], ",", "S_List"}], "]"}], ":=", 
  RowBox[{"minimalElements", "[", 
   RowBox[{
    RowBox[{"inverseRelation", "[", "R", "]"}], ",", "S"}], "]"}]}]], "Input",\

 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"maximalElements", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"Range", "[", "6", "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"4", ",", "5", ",", "6"}], "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Least Upper Bound", "Subsection",
 CellTags->"Section6d"],

Cell[TextData[{
 "Next we will write a function for computing the least upper bound of a set \
with respect to a partial order, if it exists. Our function will return the \
value ",
 StyleBox[ButtonBox["Null",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Null"], "FunctionLink"],
 " in the case that the set has no least upper bound."
}], "Text"],

Cell[TextData[{
 "First we create a function ",
 StyleBox["upperBoundQ", "Input"],
 " that determines whether a given element is an upper bound of a set with \
respect to a relation. It accomplishes this by checking to make sure that the \
given element is greater than every element of the set."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"upperBoundQ", "[", 
   RowBox[{
    RowBox[{"R_", "?", "partialOrderQ"}], ",", "S_List", ",", "u_"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "s", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{"Catch", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Do", "[", 
       RowBox[{
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{"!", 
           RowBox[{"MemberQ", "[", 
            RowBox[{"R", ",", 
             RowBox[{"{", 
              RowBox[{"s", ",", "u"}], "}"}]}], "]"}]}], ",", 
          RowBox[{"Throw", "[", "False", "]"}]}], "]"}], 
        "\[IndentingNewLine]", ",", 
        RowBox[{"{", 
         RowBox[{"s", ",", "S"}], "}"}]}], "]"}], ";", "\[IndentingNewLine]", 
      
      RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "For example, under the ",
 StyleBox["div6", "Input"],
 " relation, 6 is an upper bound of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], TraditionalForm]]],
 ", but not of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4"}], "}"}], TraditionalForm]]],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"upperBoundQ", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], ",", "6"}], "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"upperBoundQ", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4"}], "}"}], ",", "6"}], 
  "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[TextData[{
 "Next we write a function to find all of the upper bounds for a given set. \
We do this by considering every element of the domain of the relation and \
checking to see which are upper bounds, using the ",
 StyleBox["upperBoundQ", "Input"],
 " function."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"upperBounds", "[", 
   RowBox[{
    RowBox[{"R_", "?", "partialOrderQ"}], ",", "S_List"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"domR", ",", "d", ",", 
      RowBox[{"U", "=", 
       RowBox[{"{", "}"}]}]}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"domR", "=", 
      RowBox[{"findDomain", "[", "R", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{"upperBoundQ", "[", 
          RowBox[{"R", ",", "S", ",", "d"}], "]"}], ",", 
         RowBox[{"AppendTo", "[", 
          RowBox[{"U", ",", "d"}], "]"}]}], "]"}], "\[IndentingNewLine]", ",", 
       RowBox[{"{", 
        RowBox[{"d", ",", "domR"}], "}"}]}], "]"}], ";", 
     "\[IndentingNewLine]", "U"}]}], "\[IndentingNewLine]", "]"}]}]], "Input",\

 InitializationCell->True],

Cell[TextData[{
 "For instance, the upper bounds of the set ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], TraditionalForm]]],
 " under ",
 StyleBox["div6", "Input"],
 " are:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"upperBounds", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"2", ",", "4", ",", "6"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "To complete the task of finding the least upper bound of a set, we merely \
use ",
 StyleBox["upperBounds", "Input"],
 " to compute all of the upper bounds for the set, use ",
 StyleBox["minimalElements", "Input"],
 " to see which of the upper bounds are minimal, and then check to see how \
many minimal upper bounds are found. If there is exactly one minimal upper \
bound, then this is the least upper bound. Otherwise, the set has no least \
upper bound."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"leastUpperBound", "[", 
   RowBox[{
    RowBox[{"R_", "?", "partialOrderQ"}], ",", "S_List"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"U", ",", "M"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"U", "=", 
      RowBox[{"upperBounds", "[", 
       RowBox[{"R", ",", "S"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"M", "=", 
      RowBox[{"minimalElements", "[", 
       RowBox[{"R", ",", "U"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"If", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"Length", "[", "M", "]"}], "\[NotEqual]", "1"}], ",", "Null", 
       ",", 
       RowBox[{"M", "[", 
        RowBox[{"[", "1", "]"}], "]"}]}], "]"}]}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "For example, the least upper bounds of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], TraditionalForm]]],
 " are found below, while ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"4", ",", "5"}], "}"}], TraditionalForm]]],
 " has no least upper bound in the domain of ",
 StyleBox["div6", "Input"],
 " and so does not return a value."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"leastUpperBound", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData["2"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"leastUpperBound", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData["6"], "Output"]
}, Open  ]],

Cell[BoxData[
 RowBox[{"leastUpperBound", "[", 
  RowBox[{"div6", ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "5"}], "}"}]}], "]"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Lattices", "Subsection",
 CellTags->"Section6e"],

Cell[TextData[{
 "As the last topic in this section, we will consider the problem of \
determining whether a partial order is a lattice. The approach we will take \
is a good example of top down programming. The test we design here will \
confirm that the function ",
 StyleBox["divisorLattice", "Input"],
 " written at the beginning of this section does indeed produce lattices."
}], "Text"],

Cell["\<\
Recall that a partial order is a lattice if every pair of elements has both a \
least upper bound and a greatest lower bound (in lattices, these are also \
referred to as the supremum and infimum of the pair or as their meet and \
join). With this in mind, we can write the following function (with the \
understanding that the helper functions still need to be written).\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"latticeQ", "[", 
   RowBox[{"R_", "?", "partialOrderQ"}], "]"}], ":=", 
  RowBox[{
   RowBox[{"hasLUBs", "[", "R", "]"}], "&&", 
   RowBox[{"hasGLBs", "[", "R", "]"}]}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "We need to write the two helper functions: ",
 StyleBox["hasLUBs", "Input"],
 " to determine if the partial order satisfies the property that every pair \
of elements has a least upper bound, and ",
 StyleBox["hasGLBs", "Input"],
 " to determine if every pair has a greatest lower bound. Just as we did \
above with the ",
 StyleBox["maximalElements", "Input"],
 " function, we really only need to write one function if we recognize that a \
partial order satisfies the greatest lower bound property if the inverse \
relation satisfies the least upper bound property. So we compose ",
 StyleBox["hasLUBs", "Input"],
 " with the ",
 StyleBox["inverseRelation", "Input"],
 " function to create ",
 StyleBox["hasGLBs", "Input"],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"hasGLBs", "[", 
   RowBox[{"R_", "?", "partialOrderQ"}], "]"}], ":=", 
  RowBox[{"hasLUBs", "[", 
   RowBox[{"inverseRelation", "[", "R", "]"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "Now we complete the work by coding the ",
 StyleBox["hasLUBs", "Input"],
 " function. We must test whether, for a given relation ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 ", each pair ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]]],
 " in the domain of ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 " has a least upper bound with respect to ",
 Cell[BoxData[
  FormBox["R", TraditionalForm]]],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"hasLUBs", "[", 
   RowBox[{"R_", "?", "partialOrderQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"domR", ",", "a", ",", "b"}], "}"}], ",", "\[IndentingNewLine]", 
    
    RowBox[{
     RowBox[{"domR", "=", 
      RowBox[{"findDomain", "[", "R", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"Catch", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"Do", "[", 
        RowBox[{
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"leastUpperBound", "[", 
             RowBox[{"R", ",", 
              RowBox[{"{", 
               RowBox[{"a", ",", "b"}], "}"}]}], "]"}], "===", "Null"}], ",", 
           
           RowBox[{"Throw", "[", "False", "]"}]}], "]"}], 
         "\[IndentingNewLine]", ",", 
         RowBox[{"{", 
          RowBox[{"a", ",", "domR"}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"b", ",", "domR"}], "}"}]}], "]"}], ";", 
       "\[IndentingNewLine]", 
       RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", 
      "]"}]}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "Finally, all of the subroutines that go into making up the ",
 StyleBox["latticeQ", "Input"],
 " program are complete, and we can test it on some examples. Contrast the \
relations constructed by the ",
 StyleBox["dividesRelation", "Input"],
 " function versus those made by ",
 StyleBox["divisorLattice", "Input"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"latticeQ", "[", 
  RowBox[{"dividesRelation", "[", "10", "]"}], "]"}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"latticeQ", "[", 
  RowBox[{"divisorLattice", "[", "20", "]"}], "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Solutions to Computer Projects and Computations and Explorations\
\>", "Section",
 CellTags->"Solutions"],

Cell[CellGroupData[{

Cell["Computer Projects 15", "Subsection",
 CellTags->"SolutionsCP15"],

Cell["\<\
Given a partial ordering on a finite set, find a total ordering compatible \
with it using topological sorting.\
\>", "Problem"],

Cell[TextData[{
 StyleBox["Solution:",
  FontSlant->"Italic"],
 " The textbook contains a detailed explanation of topological sorting and \
summarizes it as Algorithm 1 of Section 9.6."
}], "Text"],

Cell[TextData[{
 "The set ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " is initialized to the domain of the given relation. At each step, find a \
minimal element (using the ",
 StyleBox["minimalElements", "Input"],
 " function we created above) of ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 ". This minimal element is removed from ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " and added as the next largest element of the total ordering. This repeats \
until ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " is empty and consequently all elements are in the total order."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"topologicalSort", "[", 
   RowBox[{"R_", "?", "partialOrderQ"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"S", ",", "a", ",", "T"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"T", "=", 
      RowBox[{"{", "}"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"S", "=", 
      RowBox[{"findDomain", "[", "R", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"While", "[", 
      RowBox[{
       RowBox[{"S", "\[NotEqual]", 
        RowBox[{"{", "}"}]}], ",", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"a", "=", 
         RowBox[{
          RowBox[{"minimalElements", "[", 
           RowBox[{"R", ",", "S"}], "]"}], "[", 
          RowBox[{"[", "1", "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{"S", "=", 
         RowBox[{"Complement", "[", 
          RowBox[{"S", ",", 
           RowBox[{"{", "a", "}"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{"T", "=", 
         RowBox[{"AppendTo", "[", 
          RowBox[{"T", ",", "a"}], "]"}]}]}]}], "\[IndentingNewLine]", "]"}], 
     ";", "\[IndentingNewLine]", "T"}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "We apply this procedure to ",
 StyleBox["fig10", "Input"],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"topologicalSort", "[", "fig10", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"A\"\>", ",", "\<\"C\"\>", ",", "\<\"B\"\>", ",", "\<\"D\"\>", 
   ",", "\<\"E\"\>", ",", "\<\"F\"\>", ",", "\<\"G\"\>"}], "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Computations and Explorations 1", "Subsection",
 CellTags->"SolutionsCE1"],

Cell["\<\
Display all the different relations on a set with four elements.\
\>", "Problem"],

Cell[TextData[{
 StyleBox["Solution:",
  FontSlant->"Italic"],
 " As usual, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " is much too powerful to solve only the single instance of the general \
problem suggested by this question. We provide a very simple function that \
will compute all relations on any finite set. This procedure merely \
constructs the Cartesian product ",
 Cell[BoxData[
  FormBox[
   RowBox[{"C", "=", 
    RowBox[{"S", "\[Times]", "S"}]}], TraditionalForm]]],
 " using ",
 StyleBox[ButtonBox["Tuples",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Tuples"], "FunctionLink"],
 " and then makes use of the ",
 StyleBox[ButtonBox["Subsets",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Subsets"], "FunctionLink"],
 " function to obtain all of the relations on the set."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"allRelations", "[", "S_List", "]"}], ":=", 
  RowBox[{"Subsets", "[", 
   RowBox[{"Tuples", "[", 
    RowBox[{"S", ",", "2"}], "]"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[TextData[{
 "We now test our procedure on a set with 2 elements. (This keeps the output \
to a reasonable length.) We use ",
 StyleBox[ButtonBox["Column",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Column"], "FunctionLink"],
 " to display each relation on its own line."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"allRelations", "[", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2"}], "}"}], "]"}], "//", "Column"}]], "Input"],

Cell[BoxData[
 TagBox[GridBox[{
    {
     RowBox[{"{", "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"1", ",", "1"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"1", ",", "2"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"2", ",", "1"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{"{", 
       RowBox[{"2", ",", "2"}], "}"}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]},
    {
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"1", ",", "2"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "2"}], "}"}]}], "}"}]}
   },
   DefaultBaseStyle->"Column",
   GridBoxAlignment->{"Columns" -> {{Left}}},
   GridBoxItemSize->{"Columns" -> {{Automatic}}, "Rows" -> {{Automatic}}}],
  "Column"]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The reader is encouraged to determine the running time and output length \
for the function when the input set has cardinality 4 or 5. Keep in mind that \
there are ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["2", 
    SuperscriptBox["n", "2"]], TraditionalForm]]],
 " relations on a set with ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " members."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Computations and Explorations 4", "Subsection",
 CellTags->"SolutionsCE4"],

Cell[TextData[{
 "Determine how many transitive relations there are on a set with ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " elements for all positive integers ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " with ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "\[LessEqual]", "7"}], TraditionalForm]]],
 "."
}], "Problem"],

Cell[TextData[{
 StyleBox["Solution:",
  FontSlant->"Italic"],
 " We will construct each possible ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "\[Times]", "n"}], TraditionalForm]]],
 " zero-one matrix using an algorithm similar to binary counting. The \
approach is as follows:"
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
 "For each number from 0 to ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["2", 
     SuperscriptBox["n", "2"]], "-", "1"}], TraditionalForm]]],
 ", we create a list of 0s and 1s that is the base 2 representation of that \
integer. We can do this with the ",
 StyleBox[ButtonBox["IntegerDigits",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/IntegerDigits"], "FunctionLink"],
 " function. The syntax ",
 Cell[BoxData[
  RowBox[{
   RowBox[{"IntegerDigits", "["}], "i", ",", "2", ",", 
   RowBox[{"n", "^", "2"}], "]"}]], "myCode"],
 " returns a list whose entries are the base 2 representation of the integer ",
 Cell[BoxData[
  FormBox["i", TraditionalForm]]],
 ", padded with 0s if necessary to obtain a list of length ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["n", "2"], TraditionalForm]]],
 "."
}], "Item1Numbered"],

Cell[TextData[{
 "Then create a matrix ",
 Cell[BoxData[
  FormBox["M", TraditionalForm]]],
 " whose entries are that list of values. These are all possible ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["2", 
    SuperscriptBox["n", "2"]], TraditionalForm]]],
 " zero-one matrices (the reader is encouraged to prove this statement). We \
use the ",
 StyleBox[ButtonBox["Partition",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Partition"], "FunctionLink"],
 " function on the list with second argument ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " to split the list of ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["n", "2"], TraditionalForm]]],
 " values into a ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "\[Times]", "n"}], TraditionalForm]]],
 " matrix. "
}], "Item1Numbered"],

Cell[TextData[{
 "Finally, evaluate the transitive closure of each of those matrices, using \
the ",
 StyleBox["warshall", "Input"],
 " function from Section 9.4 above. We test to see if the matrix is \
transitive by checking to see if it is equal to its transitive closure. If \
so, it is counted as a transitive relation."
}], "Item1Numbered"]
}, Open  ]],

Cell["The implementation is as follows:", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"countTransitive", "[", "n_Integer", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"i", ",", "j", ",", "T", ",", "M", ",", 
      RowBox[{"count", "=", "0"}]}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"For", "[", 
      RowBox[{
       RowBox[{"i", "=", "0"}], ",", 
       RowBox[{"i", "\[LessEqual]", 
        RowBox[{
         RowBox[{"2", "^", 
          RowBox[{"(", 
           RowBox[{"n", "^", "2"}], ")"}]}], "-", "1"}]}], ",", 
       RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"T", "=", 
         RowBox[{"IntegerDigits", "[", 
          RowBox[{"i", ",", "2", ",", 
           RowBox[{"n", "^", "2"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{"M", "=", 
         RowBox[{"Partition", "[", 
          RowBox[{"T", ",", "n"}], "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"warshall", "[", "M", "]"}], "\[Equal]", "M"}], ",", 
          RowBox[{"count", "++"}]}], "]"}]}]}], "\[IndentingNewLine]", "]"}], 
     ";", "\[IndentingNewLine]", "count"}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True],

Cell["\<\
We use the function on a relatively small value and leave further \
computations to the reader.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"countTransitive", "[", "3", "]"}]], "Input"],

Cell[BoxData["171"], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Computations and Explorations 5", "Subsection",
 CellTags->"SolutionsCE5"],

Cell["\<\
Find the transitive closure of a relation of your choice on a set with at \
least 20 elements. Either use a relation that corresponds to direct links in \
a particular transportation or communications network or use a randomly \
generated relation. \
\>", "Problem"],

Cell[TextData[{
 StyleBox["Solution:",
  FontSlant->"Italic"],
 " We will generate a random zero-one matrix with dimension ",
 Cell[BoxData[
  FormBox[
   RowBox[{"8", "\[Times]", "8"}], TraditionalForm]]],
 ", and then apply Warshall's algorithm to compute the transitive closure. \
(We use a smaller size than specified in the problem so as to be able to \
display the result easily.)"
}], "Text"],

Cell[TextData[{
 "To generate a random zero-one matrix, we use the ",
 StyleBox[ButtonBox["RandomVariate",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/RandomVariate"], "FunctionLink"],
 " function. This function was first discussed in Section 7.2. The first \
argument to ",
 StyleBox[ButtonBox["RandomVariate",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/RandomVariate"], "FunctionLink"],
 " must be a probability distribution. We will use the ",
 StyleBox[ButtonBox["BernoulliDistribution",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BernoulliDistribution"], "FunctionLink"],
 ", which randomly chooses 0 or 1, with parameter .1. This means that 1 is \
chosen with probability ",
 Cell[BoxData[
  FormBox[".1", TraditionalForm]]],
 ", resulting in a fairly sparse matrix. This increases the chance that the \
transitive closure will have entries that are not 1. The second argument to \
",
 StyleBox[ButtonBox["RandomVariate",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/RandomVariate"], "FunctionLink"],
 " specifies the number of times to sample the distribution. By using a list, \
for example ",
 StyleBox["{8,8}", "Input"],
 ", the function will output a matrix of that size."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"randomMatrix", "=", 
   RowBox[{"RandomVariate", "[", 
    RowBox[{
     RowBox[{"BernoulliDistribution", "[", ".1", "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"8", ",", "8"}], "}"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"randomMatrix", "//", "MatrixForm"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"0", "1", "0", "0", "0", "0", "0", "1"},
     {"1", "0", "0", "0", "0", "0", "1", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0"},
     {"0", "0", "1", "0", "1", "0", "1", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0"},
     {"0", "0", "0", "1", "0", "0", "0", "0"},
     {"0", "0", "1", "0", "0", "0", "0", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"warshall", "[", "randomMatrix", "]"}], "//", 
  "MatrixForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"1", "1", "1", "1", "0", "0", "1", "1"},
     {"1", "1", "1", "1", "0", "0", "1", "1"},
     {"0", "0", "0", "0", "0", "0", "0", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0"},
     {"0", "0", "1", "1", "1", "0", "1", "0"},
     {"0", "0", "0", "0", "0", "0", "0", "0"},
     {"0", "0", "0", "1", "0", "0", "0", "0"},
     {"0", "0", "1", "0", "0", "0", "0", "0"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output"]
}, Open  ]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Exercises", "Section",
 CellTags->"Exercises"],

Cell[CellGroupData[{

Cell[TextData[{
 "The ",
 StyleBox["relationToMatrix", "Input"],
 " function converts a relation satisfying ",
 StyleBox["relationQ", "Input"],
 " to a zero-one matrix representation. Write a function to convert a \
zero-one matrix representation of a relation to a ",
 StyleBox["relationQ", "Input"],
 " representation."
}], "Item1Exercise"],

Cell[TextData[{
 "Write a ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " function with the signature"
}], "Item1Exercise"]
}, Open  ]],

Cell[BoxData[
 RowBox[{"makeRelation", "[", 
  RowBox[{
   RowBox[{"S", ":", 
    RowBox[{"{", "__Integer", "}"}]}], ",", "f_Function"}], "]"}]], "myCode"],

Cell[TextData[{
 "that creates the relation ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{"a", ",", "b"}], ")"}], "\[Element]", 
     RowBox[{"S", "\[Times]", 
      RowBox[{"S", ":", 
       RowBox[{
        RowBox[{"f", "(", 
         RowBox[{"a", ",", "b"}], ")"}], " ", "is", " ", "true"}]}]}]}], 
    "}"}], TraditionalForm]]],
 ". That is, ",
 StyleBox["makeRelation", "Input"],
 " should return the set of all ordered pairs ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", 
    RowBox[{"a", ",", "b"}], ")"}], TraditionalForm]]],
 " of elements of ",
 Cell[BoxData[
  FormBox["S", TraditionalForm]]],
 " for which the pure ",
 StyleBox[ButtonBox["Function",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Function"], "FunctionLink"],
 " (&) ",
 StyleBox["f", "Input"],
 " evaluates to true when ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]]],
 " and ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]]],
 " are substituted for the ",
 StyleBox[ButtonBox["Slot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Slot"], "FunctionLink"],
 "s (#) in ",
 StyleBox["f", "Input"],
 ". For example, your function should accept an expression such as"
}], "ExerciseContinuation"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"#1", "+", "#2"}], "<", 
   RowBox[{"#1", "*", "#2"}]}], "&"}]], "myCode"],

Cell[CellGroupData[{

Cell[TextData[{
 "Write a ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " function to generate a random relation on a given finite set of integers."
}], "Item1Exercise"],

Cell["\<\
Use the function you wrote in the preceding exercise to investigate the \
probability that an arbitrary relation has each of the following properties: \
(a) reflexivity; (b) symmetry; (c) anti-symmetry; and (d) transitivity.\
\>", "Item1Exercise"],

Cell[TextData[{
 "Write ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " functions to determine whether a given relation is irreflexive or \
asymmetric. (See the text for definitions of these properties.)"
}], "Item1Exercise"],

Cell["\<\
Investigate the ratio of the size of an arbitrary relation to the size of its \
transitive closure. How much does the transitive closure make a relation \
\[OpenCurlyDoubleQuote]grow\[CloseCurlyDoubleQuote] on average?\
\>", "Item1Exercise"],

Cell[TextData[{
 "Examine the function \[CurlyPhi] defined as follows. For a positive integer \
",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 ", we define ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[CurlyPhi]", "(", "n", ")"}], TraditionalForm]]],
 " to be the number of relations on a set of ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " elements whose transitive closure is the \[OpenCurlyDoubleQuote]all\
\[CloseCurlyDoubleQuote] relation. (If ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " is a set, then the \[OpenCurlyDoubleQuote]all\[CloseCurlyDoubleQuote] \
relation on ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " is the relation ",
 Cell[BoxData[
  FormBox[
   RowBox[{"A", "\[Times]", "A"}], TraditionalForm]]],
 " with respect to which every member of ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 " is related to every other member of ",
 Cell[BoxData[
  FormBox["A", TraditionalForm]]],
 ", including itself.)"
}], "Item1Exercise"],

Cell[TextData[{
 "Write a ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " function that finds the antichain with the greatest number of elements in \
a partial ordering. (See the text for the definition of antichain.)"
}], "Item1Exercise"],

Cell[TextData[{
 "The transitive reduction of a relation ",
 Cell[BoxData[
  FormBox["G", TraditionalForm]]],
 " is the smallest relation ",
 Cell[BoxData[
  FormBox["H", TraditionalForm]]],
 " such that the transitive closure of ",
 Cell[BoxData[
  FormBox["H", TraditionalForm]]],
 " is equal to the transitive closure of ",
 Cell[BoxData[
  FormBox["G", TraditionalForm]]],
 ". Use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to generate some random relations on a set with ten elements and find the \
transitive reduction of each of these random relations."
}], "Item1Exercise"],

Cell[TextData[{
 "Write a ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " function that computes a partial order, given its covering relation."
}], "Item1Exercise"],

Cell[TextData[{
 "Write a ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " function to determine whether a given lattice is a Boolean algebra, by \
checking whether it is distributive and complemented. (See the text for \
definitions.)"
}], "Item1Exercise"]
}, Open  ]]
}, Closed]]
}, Open  ]]
},
WindowSize->{725, 850},
WindowMargins->{{12, Automatic}, {Automatic, 24}},
DockedCells->Cell[
  BoxData[
   TagBox[
    GridBox[{{"\"Exploring Discrete Mathematics with Mathematica\"", 
       ActionMenuBox[
       "\"Navigation\"", {
        "\"CloseAll\"" :> Module[{$CellContext`DJSection$}, SelectionMove[
             SelectedNotebook[], All, Notebook]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; 
           Do[NotebookLocate[$CellContext`DJSection$]; FrontEndExecute[
               FrontEndToken["OpenCloseGroup"]], {$CellContext`DJSection$, {
              "Section1a", "Section1b", "Section1c", "Section2a", "Section3a",
                "Section3b", "Section3c", "Section4a", "Section4b", 
               "Section4c", "Section5a", "Section5b", "Section5c", 
               "Section6a", "Section6b", "Section6c", "Section6d", 
               "Section6e", "SolutionsCE1", "SolutionsCE4", "SolutionsCE5", 
               "SolutionsCP15", "Section1", "Section2", "Section3", 
               "Section4", "Section5", "Section6", "Solutions", 
               "Exercises"}}]; SelectionMove[
             SelectedNotebook[], Before, Notebook]], "\"Section1\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Section1"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section2\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Section2"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section3\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Section3"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section4\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Section4"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section5\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Section5"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section6\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Section6"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Solutions\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Solutions"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Exercises\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Solutions", "Exercises"}}] 
            NotebookLocate["Exercises"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Open All\"" :> 
         Module[{$CellContext`DJSection$}, 
           Do[NotebookLocate[$CellContext`DJSection$]; FrontEndExecute[
               FrontEndToken[
               "SelectionOpenAllGroups"]], {$CellContext`DJSection$, {
              "Exercises", "Section1", "Section1a", "Section1b", "Section1c", 
               "Section2", "Section2a", "Section3", "Section3a", "Section3b", 
               "Section3c", "Section4", "Section4a", "Section4b", "Section4c",
                "Section5", "Section5a", "Section5b", "Section5c", "Section6",
                "Section6a", "Section6b", "Section6c", "Section6d", 
               "Section6e", "Solutions", "SolutionsCE1", "SolutionsCE4", 
               "SolutionsCE5", "SolutionsCP15"}}] SelectionMove[
             SelectedNotebook[], Before, Notebook]]}]}}, 
     GridBoxAlignment -> {
      "Columns" -> {Left, Baseline}, "Rows" -> {Right, Baseline}}, AutoDelete -> 
     False, GridBoxItemSize -> {"Columns" -> {
         Scaled[0.8], 
         Scaled[0.2]}}], "Grid"]], "DockedCell", FontFamily -> "Times"],
PrintingCopies->1,
PrintingPageRange->{1, Automatic},
Magnification->1,
FrontEndVersion->"9.0 for Mac OS X x86 (32-bit, 64-bit Kernel) (January 25, \
2013)",
StyleDefinitions->Notebook[{
   Cell[
    StyleData[
    StyleDefinitions -> 
     FrontEnd`FileName[{"Book"}, "Textbook.nb", CharacterEncoding -> 
       "UTF-8"]]], 
   Cell[
    StyleData[All, "Printout"], PageWidth -> PaperWidth, 
    CellHorizontalScrolling -> True, 
    CellLabelMargins -> {{2, Inherited}, {Inherited, Inherited}}, 
    ShowAutoStyles -> False, 
    AutoStyleOptions -> {"HighlightMisspelledWords" -> False}, ScriptMinSize -> 
    9, MenuSortingValue -> 1500, 
    PrivateFontOptions -> {"FontType" -> "Outline"}, Magnification -> 1], 
   Cell[
    StyleData["Title"], Editable -> False, ShowCellBracket -> Automatic, 
    CellGroupingRules -> {"TitleGrouping", 0}, PageBreakBelow -> False, 
    DefaultNewInlineCellStyle -> {}, LanguageCategory -> "NaturalLanguage", 
    FontFamily -> "Helvetica", FontSize -> 25, FontWeight -> "Bold", 
    FontColor -> GrayLevel[0.137255]], 
   Cell[
    StyleData["BookChapterTitle", StyleDefinitions -> StyleData["Title"]], 
    CellFrame -> {{0, 0}, {1, 1}}, CellDingbat -> Cell[
      BoxData[
       GraphicsBox[{{
          RGBColor[0.09375, 0.570313, 0.816406], 
          RectangleBox[{0, 0}]}, {
          GrayLevel[1], FontSize -> 35, FontWeight -> Bold, FontFamily -> 
          "Helvetica", 
          InsetBox[
           CounterBox["ChapterNumber"], {0.5, 0.45}, {Center, Center}]}}, 
        ImageSize -> {70, 70}]], "Output"], CellMargins -> {{75, 0}, {20, 5}},
     CellFrameColor -> GrayLevel[1]], 
   Cell[
    StyleData["DockedCell"], CellMargins -> {{0, 12}, {0, 0}}, 
    CellGroupingRules -> "TitleGrouping", 
    ConversionRules :> {"TeX" -> {"\n\\chapter{", "}"}}, 
    TaggingRules :> {"CounterSettings" -> {"CounterTarget" -> "CellGroup"}}, 
    PageBreakAbove -> False, PageBreakBelow -> False, LineSpacing -> {1, 2}, 
    MenuSortingValue -> 1105, FontFamily -> "Helvetica", FontSize -> 20, 
    FontWeight -> "Bold", Background -> 
    RGBColor[0.09375, 0.570313, 0.816406]], 
   Cell[
    StyleData["FunctionLink"], ConversionRules :> {"TeX" -> {{"", 
         $CellContext`ExportAsHyperRef[], ""}, {"", Automatic, ""}}}, 
    MenuSortingValue -> 1105, ButtonStyleMenuListing -> None, FontFamily -> 
    "Courier", FontVariations -> {"Underline" -> True}, FontColor -> 
    RGBColor[0, 0, 1], 
    ButtonBoxOptions -> {Active -> True, ButtonFunction :> (FrontEndExecute[{
         FrontEnd`NotebookLocate[#2]}]& ), ButtonNote -> ButtonData}], 
   Cell[
    StyleData["Problem"], CellMargins -> {{40, 12}, {15, 15}}, 
    CellGroupingRules -> {"GroupTogetherNestedGrouping", 15010}, 
    ConversionRules :> {
     "TeX" -> {{"", Automatic, ""}, {"\n\n", Automatic, ""}}}, 
    TaggingRules :> {
     "ExtraConversionRules" -> {"General" -> {"RestartList" -> False}}}], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Item1Exercise"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item1Exercise"], "."}], CellSize -> {30, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{50, 12}, {3, 5}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17000}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, CounterIncrements -> "Item1Exercise", 
       CounterAssignments -> {{"Item2Exercise", 0}}, MenuSortingValue -> 
       4100], 
      Cell[
       StyleData["Item1Exercise", "Printout"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item1Exercise"], "."}], CellSize -> {20, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{35, 12}, {3, 5}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17000}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6]}, Open]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["ExerciseContinuation"], CellMargins -> {{50, 12}, {1, 3}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17000}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, MenuSortingValue -> 4101], 
      Cell[
       StyleData["ExerciseContinuation", "Printout"], 
       CellMargins -> {{35, 12}, {1, 3}}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6]}, Open]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Item2Exercise"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item2Exercise"], "."}], CellSize -> {32, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{75, 12}, {1, 2}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17100}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, CounterIncrements -> "Item2Exercise", MenuSortingValue -> 4200, 
       CounterBoxOptions -> {CounterFunction :> (Part[
           CharacterRange["a", "z"], #]& )}], 
      Cell[
       StyleData["Item2Exercise", "Printout"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item2Exercise"], "."}], CellSize -> {20, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{50, 12}, {1, 2}}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, CounterBoxOptions -> {CounterFunction :> (Part[
           CharacterRange["a", "z"], #]& )}]}, Open]], 
   Cell[
    StyleData["ExerciseEquation"], CellMargins -> {{36, 12}, {7, 7}}, 
    CellGroupingRules -> {"GroupTogetherNestedGrouping", 17200}, 
    CellHorizontalScrolling -> True, 
    CellFrameLabels -> {{None, None}, {None, None}}, DefaultFormatType -> 
    TraditionalForm, InputAutoReplacements -> {}, TextAlignment -> Center, 
    MenuSortingValue -> 4300, 
    ButtonBoxOptions -> {Appearance -> {Automatic, None}}], 
   Cell[
    StyleData["myCode"], CellMargins -> {{66, 10}, {5, 10}}, 
    StyleKeyMapping -> {"=" -> "WolframAlphaShort"}, Evaluatable -> False, 
    CellGroupingRules -> "InputGrouping", TextClipboardType -> "InputText", 
    PageBreakWithin -> False, GroupPageBreakWithin -> False, 
    DefaultFormatType -> DefaultInputFormatType, ContextMenu -> 
    FEPrivate`FrontEndResource["ContextMenus", "myCode"], ShowAutoStyles -> 
    True, "TwoByteSyntaxCharacterAutoReplacement" -> True, 
    HyphenationOptions -> {"HyphenationCharacter" -> "\[Continuation]"}, 
    AutoItalicWords -> {}, LanguageCategory -> "Mathematica", FormatType -> 
    InputForm, NumberMarks -> True, 
    LinebreakAdjustments -> {0.85, 2, 10, 0, 1}, CounterIncrements -> "Code", 
    MenuSortingValue -> 1495, MenuCommandKey -> "8", FontWeight -> 
    "Bold", $CellContext`StripStyleOnPaste -> 
    True, $CellContext`AutoQuoteCharacters -> {}, \
$CellContext`PasteAutoQuoteCharacters -> {}], 
   Cell[
    StyleData["CodeVar"], DefaultFormatType -> DefaultInputFormatType, 
    LineBreakWithin -> False, MenuSortingValue -> 10000, FontWeight -> "Bold",
     FontSlant -> "Italic", FontColor -> GrayLevel[0.4]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Section"], CellFrame -> {{6, 0}, {0, 1}}, ShowCellBracket -> 
       Automatic, CellMargins -> {{12, 12}, {3, 24}}, 
       CellGroupingRules -> {"SectionGrouping", 30}, 
       ConversionRules :> {
        "TeX" -> {"\n\\section{", "}"}, 
         "HTML" -> {"<h3 class=\"Section\">", "</h3>"}}, 
       TaggingRules :> {
        "CounterSettings" -> {
          "CounterFormat" -> {"BookChapterNumber", ".", "Section"}, 
           "CounterTarget" -> "Cell", "XRefPrefix" -> "Section"}}, 
       PageBreakBelow -> False, CellFrameMargins -> {{8, 8}, {4, 6}}, 
       CellFrameColor -> RGBColor[0.09375, 0.570313, 0.816406], TabSpacings -> 
       2.1, CounterIncrements -> {
        "Section", "SectionHeader", "SubsectionHeader", "SubsubsectionHeader",
          "SubsubsubsectionHeader"}, FontFamily -> "Helvetica", FontSize -> 
       16, FontWeight -> "Bold", Background -> GrayLevel[0.999985]], 
      Cell[
       StyleData["Section", "Printout"], CellFrame -> {{4, 0}, {0, 0.5}}, 
       CellMargins -> {{2, 2}, {3, 21}}, PageBreakBelow -> False, 
       CellFrameMargins -> {{6, 6}, {3, 5}}, CellFrameColor -> 
       RGBColor[0.09375, 0.570313, 0.816406]], 
      Cell[
       StyleData["Section", "DoubleSpacedPrintout"], 
       CellFrame -> {{4, 0}, {0, 0.5}}, CellMargins -> {{2, 2}, {3, 21}}, 
       PageBreakBelow -> False, CellFrameMargins -> {{6, 6}, {3, 5}}, 
       CellFrameColor -> RGBColor[0.09375, 0.570313, 0.816406], FontSize -> 
       14]}, Open]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Subsubsection"], CellDingbat -> None, 
       CellMargins -> {{12, 12}, {0, 6}}, 
       CellElementSpacings -> {"ClosedGroupTopMargin" -> 12}, 
       CellGroupingRules -> {"SectionGrouping", 50}, 
       ConversionRules :> {
        "TeX" -> {"\n\\subsubsection{", "}"}, 
         "HTML" -> {"<h5 class=\"Subsubsection\">", "</h5>"}}, PageBreakBelow -> 
       False, CellFrameLabelMargins -> 4, 
       CounterIncrements -> {
        "Subsubsection", "SubsubsectionHeader", "SubsubsubsectionHeader"}, 
       FontFamily -> "Helvetica", FontSize -> 11, FontWeight -> "Bold", 
       FontSlant -> "Italic"], 
      Cell[
       StyleData["Subsubsection", "Printout"], PageBreakBelow -> False, 
       FontFamily -> "Helvetica", FontSize -> 11, FontWeight -> "Bold", 
       FontSlant -> "Italic"]}, Open]], 
   Cell[
    StyleData["Equation"], CellMargins -> {{26, 10}, {7, 7}}, 
    ConversionRules :> {
     "HTML" -> {{"", ""}, {"<p class=\"Equation\">", "</p>"}}}, 
    CellHorizontalScrolling -> True, DefaultFormatType -> TraditionalForm, 
    InputAutoReplacements -> {}, TextAlignment -> Center, CounterIncrements -> 
    "Equation", ButtonBoxOptions -> {Appearance -> {Automatic, None}}], 
   Cell[
    StyleData["Subsubsubsection"], CellDingbat -> None, 
    CellMargins -> {{12, 12}, {0, 6}}, 
    CellGroupingRules -> {"SectionGrouping", 60}, 
    ConversionRules :> {
     "TeX" -> {"\n\\subsubsubsection{", "}"}, 
      "HTML" -> {"<h6 class=\"Subsubsubsection\">", "</h6>"}}, PageBreakBelow -> 
    False, CellFrameLabelMargins -> 4, 
    CounterIncrements -> {"Subsubsubsection", "SubsubsubsectionHeader"}, 
    FontFamily -> "Helvetica", FontSize -> 11, FontSlant -> "Italic"]}, 
  Visible -> False, FrontEndVersion -> 
  "9.0 for Mac OS X x86 (32-bit, 64-bit Kernel) (January 25, 2013)", 
  StyleDefinitions -> "PrivateStylesheetFormatting.nb"]
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{
 "Section1"->{
  Cell[2274, 76, 76, 1, 55, "Section",
   CellTags->"Section1"]},
 "Section1a"->{
  Cell[3019, 99, 72, 1, 32, "Subsection",
   CellTags->"Section1a"]},
 "Section1b"->{
  Cell[10540, 350, 64, 1, 26, "Subsection",
   CellTags->"Section1b"]},
 "Section1c"->{
  Cell[21560, 756, 69, 1, 26, "Subsection",
   CellTags->"Section1c"]},
 "Section2"->{
  Cell[41326, 1458, 153, 6, 36, "Section",
   CellTags->"Section2"]},
 "Section2a"->{
  Cell[45055, 1592, 144, 6, 33, "Subsection",
   CellTags->"Section2a"]},
 "Section3"->{
  Cell[57911, 2036, 68, 1, 35, "Section",
   CellTags->"Section3"]},
 "Section3a"->{
  Cell[58273, 2048, 83, 1, 32, "Subsection",
   CellTags->"Section3a"]},
 "Section3b"->{
  Cell[76766, 2656, 83, 1, 26, "Subsection",
   CellTags->"Section3b"]},
 "Section3c"->{
  Cell[101515, 3258, 106, 5, 27, "Subsection",
   CellTags->"Section3c"]},
 "Section4"->{
  Cell[122946, 3819, 67, 1, 35, "Section",
   CellTags->"Section4"]},
 "Section4a"->{
  Cell[123232, 3830, 88, 2, 32, "Subsection",
   PageBreakWithin->False,
   CellTags->"Section4a"]},
 "Section4b"->{
  Cell[126860, 3947, 63, 1, 26, "Subsection",
   CellTags->"Section4b"]},
 "Section4c"->{
  Cell[130834, 4082, 64, 1, 26, "Subsection",
   CellTags->"Section4c"]},
 "Section5"->{
  Cell[155585, 4909, 67, 1, 35, "Section",
   CellTags->"Section5"]},
 "Section5a"->{
  Cell[159791, 5049, 65, 1, 32, "Subsection",
   CellTags->"Section5a"]},
 "Section5b"->{
  Cell[165079, 5232, 86, 1, 26, "Subsection",
   CellTags->"Section5b"]},
 "Section5c"->{
  Cell[177285, 5684, 53, 1, 26, "Subsection",
   CellTags->"Section5c"]},
 "Section6"->{
  Cell[187755, 6028, 63, 1, 35, "Section",
   CellTags->"Section6"]},
 "Section6a"->{
  Cell[188213, 6043, 73, 1, 32, "Subsection",
   CellTags->"Section6a"]},
 "Section6b"->{
  Cell[196087, 6293, 60, 1, 26, "Subsection",
   CellTags->"Section6b"]},
 "Section6c"->{
  Cell[221281, 7054, 74, 1, 26, "Subsection",
   CellTags->"Section6c"]},
 "Section6d"->{
  Cell[226439, 7230, 63, 1, 26, "Subsection",
   CellTags->"Section6d"]},
 "Section6e"->{
  Cell[233129, 7468, 54, 1, 26, "Subsection",
   CellTags->"Section6e"]},
 "Solutions"->{
  Cell[237659, 7614, 115, 3, 35, "Section",
   CellTags->"Solutions"]},
 "SolutionsCP15"->{
  Cell[237799, 7621, 70, 1, 32, "Subsection",
   CellTags->"SolutionsCP15"]},
 "SolutionsCE1"->{
  Cell[240494, 7710, 80, 1, 26, "Subsection",
   CellTags->"SolutionsCE1"]},
 "SolutionsCE4"->{
  Cell[245582, 7900, 80, 1, 26, "Subsection",
   CellTags->"SolutionsCE4"]},
 "SolutionsCE5"->{
  Cell[249944, 8048, 80, 1, 26, "Subsection",
   CellTags->"SolutionsCE5"]},
 "Exercises"->{
  Cell[254356, 8176, 52, 1, 35, "Section",
   CellTags->"Exercises"]}
 }
*)
(*CellTagsIndex
CellTagsIndex->{
 {"Section1", 277372, 8698},
 {"Section1a", 277454, 8701},
 {"Section1b", 277540, 8704},
 {"Section1c", 277628, 8707},
 {"Section2", 277715, 8710},
 {"Section2a", 277801, 8713},
 {"Section3", 277890, 8716},
 {"Section3a", 277975, 8719},
 {"Section3b", 278064, 8722},
 {"Section3c", 278153, 8725},
 {"Section4", 278243, 8728},
 {"Section4a", 278329, 8731},
 {"Section4b", 278446, 8735},
 {"Section4c", 278536, 8738},
 {"Section5", 278625, 8741},
 {"Section5a", 278711, 8744},
 {"Section5b", 278801, 8747},
 {"Section5c", 278891, 8750},
 {"Section6", 278980, 8753},
 {"Section6a", 279066, 8756},
 {"Section6b", 279156, 8759},
 {"Section6c", 279246, 8762},
 {"Section6d", 279336, 8765},
 {"Section6e", 279426, 8768},
 {"Solutions", 279516, 8771},
 {"SolutionsCP15", 279608, 8774},
 {"SolutionsCE1", 279705, 8777},
 {"SolutionsCE4", 279801, 8780},
 {"SolutionsCE5", 279897, 8783},
 {"Exercises", 279990, 8786}
 }
*)
(*NotebookFileOutline
Notebook[{
Cell[CellGroupData[{
Cell[579, 22, 82, 1, 96, "BookChapterTitle",
 CounterAssignments->{{"ChapterNumber", 9}}],
Cell[CellGroupData[{
Cell[686, 27, 31, 0, 55, "Section"],
Cell[720, 29, 438, 11, 50, "Text"],
Cell[1161, 42, 540, 12, 65, "Text"],
Cell[1704, 56, 533, 15, 50, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[2274, 76, 76, 1, 55, "Section",
 CellTags->"Section1"],
Cell[2353, 79, 641, 16, 65, "Text"],
Cell[CellGroupData[{
Cell[3019, 99, 72, 1, 32, "Subsection",
 CellTags->"Section1a"],
Cell[3094, 102, 444, 7, 50, "Text"],
Cell[3541, 111, 196, 6, 29, "Input",
 InitializationCell->True],
Cell[3740, 119, 621, 16, 107, "Input",
 InitializationCell->True],
Cell[4364, 137, 647, 17, 53, "Text"],
Cell[CellGroupData[{
Cell[5036, 158, 82, 2, 29, "Input"],
Cell[5121, 162, 83, 2, 29, "Output"]
}, Open  ]],
Cell[5219, 167, 366, 7, 51, "Text"],
Cell[5588, 176, 451, 10, 36, "Text"],
Cell[6042, 188, 398, 9, 51, "Text"],
Cell[6443, 199, 276, 9, 45, "Input",
 InitializationCell->True],
Cell[6722, 210, 1242, 30, 100, "Text"],
Cell[7967, 242, 555, 14, 52, "Text"],
Cell[CellGroupData[{
Cell[8547, 260, 113, 3, 29, "Input"],
Cell[8663, 265, 31, 0, 28, "Output"]
}, Open  ]],
Cell[8709, 268, 318, 9, 36, "Text"],
Cell[CellGroupData[{
Cell[9052, 281, 58, 1, 29, "Input"],
Cell[9113, 284, 32, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[9182, 289, 115, 3, 29, "Input"],
Cell[9300, 294, 32, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[9369, 299, 81, 2, 29, "Input"],
Cell[9453, 303, 32, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[9522, 308, 53, 1, 29, "Input"],
Cell[9578, 311, 32, 0, 28, "Output"]
}, Open  ]],
Cell[9625, 314, 130, 6, 21, "Text"],
Cell[9758, 322, 290, 9, 45, "Input",
 InitializationCell->True],
Cell[10051, 333, 452, 12, 37, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[10540, 350, 64, 1, 26, "Subsection",
 CellTags->"Section1b"],
Cell[10607, 353, 143, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[10775, 360, 45, 0, 18, "Subsubsection"],
Cell[10823, 362, 834, 24, 53, "Text"],
Cell[11660, 388, 546, 14, 51, "Text"],
Cell[CellGroupData[{
Cell[12231, 406, 141, 4, 29, "Input"],
Cell[12375, 412, 584, 20, 28, "Output"]
}, Open  ]],
Cell[12974, 435, 1211, 36, 68, "Text"],
Cell[14188, 473, 180, 5, 21, "Text"],
Cell[14371, 480, 504, 16, 29, "Input",
 InitializationCell->True],
Cell[14878, 498, 108, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[15011, 505, 100, 2, 29, "Input"],
Cell[15114, 509, 525, 18, 28, "Output"]
}, Open  ]],
Cell[15654, 530, 146, 5, 21, "Text"],
Cell[CellGroupData[{
Cell[15825, 539, 62, 1, 28, "Input"],
Cell[15890, 542, 31, 0, 28, "Output"]
}, Open  ]],
Cell[15936, 545, 459, 14, 36, "Text"],
Cell[16398, 561, 491, 15, 45, "Input",
 InitializationCell->True],
Cell[16892, 578, 28, 0, 20, "Text"],
Cell[CellGroupData[{
Cell[16945, 582, 121, 3, 28, "Input",
 InitializationCell->True],
Cell[17069, 587, 879, 30, 44, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[17997, 623, 50, 0, 18, "Subsubsection"],
Cell[18050, 625, 171, 3, 35, "Text"],
Cell[18224, 630, 639, 24, 40, "Text"],
Cell[18866, 656, 210, 6, 29, "Input",
 InitializationCell->True],
Cell[19079, 664, 371, 11, 21, "Text"],
Cell[CellGroupData[{
Cell[19475, 679, 117, 3, 28, "Input"],
Cell[19595, 684, 83, 2, 28, "Output"]
}, Open  ]],
Cell[19693, 689, 480, 13, 37, "Text"],
Cell[20176, 704, 292, 6, 21, "Text"],
Cell[CellGroupData[{
Cell[20493, 714, 124, 3, 28, "Input",
 InitializationCell->True],
Cell[20620, 719, 879, 30, 44, "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[21560, 756, 69, 1, 26, "Subsection",
 CellTags->"Section1c"],
Cell[21632, 759, 675, 18, 51, "Text"],
Cell[22310, 779, 777, 15, 67, "Text"],
Cell[23090, 796, 974, 34, 44, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[24089, 834, 90, 2, 28, "Input"],
Cell[24182, 838, 571, 19, 28, "Output"]
}, Open  ]],
Cell[24768, 860, 226, 6, 21, "Text"],
Cell[24997, 868, 301, 5, 35, "Text"],
Cell[25301, 875, 239, 7, 29, "Input",
 InitializationCell->True],
Cell[25543, 884, 174, 4, 20, "Text"],
Cell[CellGroupData[{
Cell[25742, 892, 66, 1, 28, "Input"],
Cell[25811, 895, 116, 3, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[25964, 903, 70, 1, 28, "Input"],
Cell[26037, 906, 209, 7, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[26283, 918, 36, 0, 18, "Subsubsection"],
Cell[26322, 920, 465, 15, 35, "Text"],
Cell[26790, 937, 873, 27, 52, "Text"],
Cell[27666, 966, 1062, 29, 135, "Input",
 InitializationCell->True],
Cell[28731, 997, 605, 17, 52, "Text"],
Cell[29339, 1016, 113, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[29477, 1023, 66, 1, 28, "Input"],
Cell[29546, 1026, 31, 0, 28, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[29626, 1032, 33, 0, 18, "Subsubsection"],
Cell[29662, 1034, 730, 18, 65, "Text"],
Cell[30395, 1054, 862, 24, 120, "Input",
 InitializationCell->True],
Cell[31260, 1080, 140, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[31425, 1087, 66, 1, 29, "Input"],
Cell[31494, 1090, 32, 0, 28, "Output"]
}, Open  ]],
Cell[31541, 1093, 181, 4, 20, "Text"],
Cell[CellGroupData[{
Cell[31747, 1101, 146, 4, 28, "Input",
 InitializationCell->True],
Cell[31896, 1107, 1351, 46, 44, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[33284, 1158, 71, 1, 29, "Input"],
Cell[33358, 1161, 31, 0, 28, "Output"]
}, Open  ]],
Cell[33404, 1164, 970, 32, 50, "Text"],
Cell[34377, 1198, 1058, 29, 120, "Input",
 InitializationCell->True],
Cell[35438, 1229, 240, 5, 20, "Text"],
Cell[CellGroupData[{
Cell[35703, 1238, 70, 1, 29, "Input"],
Cell[35776, 1241, 31, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[35844, 1246, 70, 1, 29, "Input"],
Cell[35917, 1249, 31, 0, 28, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[35997, 1255, 37, 0, 18, "Subsubsection"],
Cell[36037, 1257, 634, 24, 35, "Text"],
Cell[36674, 1283, 1017, 39, 50, "Text"],
Cell[37694, 1324, 37, 0, 20, "Text"],
Cell[37734, 1326, 1587, 43, 150, "Input",
 InitializationCell->True],
Cell[39324, 1371, 587, 22, 35, "Text"],
Cell[CellGroupData[{
Cell[39936, 1397, 67, 1, 28, "Input"],
Cell[40006, 1400, 31, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[40074, 1405, 219, 7, 29, "Input",
 InitializationCell->True],
Cell[40296, 1414, 820, 28, 44, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[41153, 1447, 65, 1, 28, "Input"],
Cell[41221, 1450, 32, 0, 28, "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]]
}, Closed]],
Cell[CellGroupData[{
Cell[41326, 1458, 153, 6, 36, "Section",
 CellTags->"Section2"],
Cell[41482, 1466, 699, 21, 51, "Text"],
Cell[42184, 1489, 231, 7, 45, "Input",
 InitializationCell->True],
Cell[42418, 1498, 292, 9, 45, "Input",
 InitializationCell->True],
Cell[42713, 1509, 95, 2, 20, "Text"],
Cell[42811, 1513, 533, 17, 44, "Input",
 InitializationCell->True],
Cell[43347, 1532, 317, 7, 36, "Text"],
Cell[CellGroupData[{
Cell[43689, 1543, 64, 1, 28, "Input"],
Cell[43756, 1546, 31, 0, 28, "Output"]
}, Open  ]],
Cell[43802, 1549, 429, 9, 50, "Text"],
Cell[44234, 1560, 340, 9, 45, "Input",
 InitializationCell->True],
Cell[44577, 1571, 312, 9, 45, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[44914, 1584, 70, 1, 28, "Input"],
Cell[44987, 1587, 31, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[45055, 1592, 144, 6, 33, "Subsection",
 CellTags->"Section2a"],
Cell[45202, 1600, 191, 5, 20, "Text"],
Cell[CellGroupData[{
Cell[45418, 1609, 35, 0, 18, "Subsubsection"],
Cell[45456, 1611, 384, 9, 51, "Text"],
Cell[45843, 1622, 316, 10, 29, "Input",
 InitializationCell->True],
Cell[46162, 1634, 261, 8, 37, "Text"],
Cell[46426, 1644, 87, 2, 20, "Text"],
Cell[CellGroupData[{
Cell[46538, 1650, 141, 4, 29, "Input"],
Cell[46682, 1656, 260, 8, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[46979, 1669, 151, 4, 29, "Input"],
Cell[47133, 1675, 374, 11, 28, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[47556, 1692, 29, 0, 18, "Subsubsection"],
Cell[47588, 1694, 186, 4, 35, "Text"],
Cell[47777, 1700, 100, 2, 20, "Text"],
Cell[CellGroupData[{
Cell[47902, 1706, 303, 11, 16, "Item1Numbered"],
Cell[48208, 1719, 321, 14, 16, "Item1Numbered"],
Cell[48532, 1735, 461, 20, 16, "Item1Numbered"],
Cell[48996, 1757, 228, 6, 29, "Item1Numbered"]
}, Open  ]],
Cell[49239, 1766, 1924, 53, 217, "Input",
 InitializationCell->True],
Cell[51166, 1821, 1381, 50, 71, "Text"],
Cell[52550, 1873, 1077, 36, 68, "Text"],
Cell[53630, 1911, 152, 4, 21, "Text"],
Cell[53785, 1917, 1076, 26, 141, "Input",
 InitializationCell->True],
Cell[54864, 1945, 1471, 37, 156, "Input",
 InitializationCell->True],
Cell[56338, 1984, 234, 8, 21, "Text"],
Cell[CellGroupData[{
Cell[56597, 1996, 164, 4, 29, "Input"],
Cell[56764, 2002, 1074, 26, 120, "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]]
}, Closed]],
Cell[CellGroupData[{
Cell[57911, 2036, 68, 1, 35, "Section",
 CellTags->"Section3"],
Cell[57982, 2039, 266, 5, 35, "Text"],
Cell[CellGroupData[{
Cell[58273, 2048, 83, 1, 32, "Subsection",
 CellTags->"Section3a"],
Cell[58359, 2051, 91, 2, 20, "Text"],
Cell[CellGroupData[{
Cell[58475, 2057, 40, 0, 18, "Subsubsection"],
Cell[58518, 2059, 313, 7, 36, "Text"],
Cell[CellGroupData[{
Cell[58856, 2070, 208, 7, 28, "Input"],
Cell[59067, 2079, 585, 17, 56, "Output"]
}, Open  ]],
Cell[59667, 2099, 414, 11, 36, "Text"],
Cell[60084, 2112, 819, 15, 82, "Text"],
Cell[60906, 2129, 207, 6, 20, "Text"],
Cell[CellGroupData[{
Cell[61138, 2139, 299, 8, 45, "Input",
 InitializationCell->True],
Cell[61440, 2149, 659, 19, 88, "Output"]
}, Open  ]],
Cell[62114, 2171, 868, 27, 52, "Text"],
Cell[CellGroupData[{
Cell[63007, 2202, 165, 5, 29, "Input",
 InitializationCell->True],
Cell[63175, 2209, 28, 0, 28, "Output"]
}, Open  ]],
Cell[63218, 2212, 55, 0, 20, "Text"],
Cell[CellGroupData[{
Cell[63298, 2216, 71, 1, 29, "Input"],
Cell[63372, 2219, 659, 19, 88, "Output"]
}, Open  ]],
Cell[64046, 2241, 349, 9, 20, "Text"],
Cell[CellGroupData[{
Cell[64420, 2254, 426, 14, 61, "Input",
 InitializationCell->True],
Cell[64849, 2270, 659, 19, 88, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[65557, 2295, 104, 2, 18, "Subsubsection"],
Cell[65664, 2299, 755, 16, 68, "Text"],
Cell[66422, 2317, 1002, 29, 123, "Input",
 InitializationCell->True],
Cell[67427, 2348, 1962, 65, 101, "Text"],
Cell[69392, 2415, 208, 7, 21, "Text"],
Cell[CellGroupData[{
Cell[69625, 2426, 214, 6, 44, "Input",
 InitializationCell->True],
Cell[69842, 2434, 773, 21, 120, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[70652, 2460, 229, 6, 44, "Input",
 InitializationCell->True],
Cell[70884, 2468, 773, 21, 120, "Output"]
}, Open  ]],
Cell[71672, 2492, 246, 4, 35, "Text"],
Cell[71921, 2498, 882, 23, 68, "Text"],
Cell[72806, 2523, 331, 7, 36, "Text"],
Cell[73140, 2532, 721, 22, 61, "Input",
 InitializationCell->True],
Cell[73864, 2556, 289, 5, 35, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[74190, 2566, 44, 0, 18, "Subsubsection"],
Cell[74237, 2568, 242, 4, 35, "Text"],
Cell[74482, 2574, 1161, 30, 150, "Input",
 InitializationCell->True],
Cell[75646, 2606, 74, 0, 20, "Text"],
Cell[CellGroupData[{
Cell[75745, 2610, 81, 1, 29, "Input"],
Cell[75829, 2613, 32, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[75898, 2618, 73, 1, 28, "Input"],
Cell[75974, 2621, 31, 0, 28, "Output"]
}, Open  ]],
Cell[76020, 2624, 403, 10, 36, "Text"],
Cell[CellGroupData[{
Cell[76448, 2638, 73, 1, 29, "Input"],
Cell[76524, 2641, 32, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[76593, 2646, 78, 1, 29, "Input"],
Cell[76674, 2649, 31, 0, 28, "Output"]
}, Open  ]]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[76766, 2656, 83, 1, 26, "Subsection",
 CellTags->"Section3b"],
Cell[76852, 2659, 789, 20, 52, "Text"],
Cell[77644, 2681, 504, 10, 51, "Text"],
Cell[CellGroupData[{
Cell[78173, 2695, 345, 8, 29, "Input"],
Cell[78521, 2705, 1071, 31, 375, "Output"]
}, Open  ]],
Cell[79607, 2739, 476, 12, 36, "Text"],
Cell[CellGroupData[{
Cell[80108, 2755, 417, 9, 45, "Input"],
Cell[80528, 2766, 1122, 27, 375, "Output"]
}, Open  ]],
Cell[81665, 2796, 854, 23, 52, "Text"],
Cell[82522, 2821, 644, 17, 52, "Text"],
Cell[CellGroupData[{
Cell[83191, 2842, 142, 3, 29, "Input"],
Cell[83336, 2847, 2769, 59, 206, "Output"]
}, Open  ]],
Cell[86120, 2909, 323, 8, 36, "Text"],
Cell[86446, 2919, 592, 15, 52, "Text"],
Cell[CellGroupData[{
Cell[87063, 2938, 121, 3, 29, "Input"],
Cell[87187, 2943, 613, 16, 44, "Output"]
}, Open  ]],
Cell[87815, 2962, 121, 4, 21, "Text"],
Cell[CellGroupData[{
Cell[87961, 2970, 57, 1, 28, "Input"],
Cell[88021, 2973, 613, 16, 44, "Output"]
}, Open  ]],
Cell[88649, 2992, 68, 0, 20, "Text"],
Cell[CellGroupData[{
Cell[88742, 2996, 170, 4, 29, "Input"],
Cell[88915, 3002, 6143, 112, 297, "Output"]
}, Open  ]],
Cell[95073, 3117, 324, 8, 36, "Text"],
Cell[95400, 3127, 349, 9, 45, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[95774, 3140, 108, 2, 28, "Input"],
Cell[95885, 3144, 5581, 108, 151, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[101515, 3258, 106, 5, 27, "Subsection",
 CellTags->"Section3c"],
Cell[101624, 3265, 303, 6, 35, "Text"],
Cell[101930, 3273, 881, 24, 53, "Text"],
Cell[CellGroupData[{
Cell[102836, 3301, 144, 4, 29, "Input",
 InitializationCell->True],
Cell[102983, 3307, 8519, 172, 286, "Output"]
}, Open  ]],
Cell[111517, 3482, 1242, 33, 69, "Text"],
Cell[CellGroupData[{
Cell[112784, 3519, 169, 4, 29, "Input",
 InitializationCell->True],
Cell[112956, 3525, 2769, 59, 206, "Output"]
}, Open  ]],
Cell[115740, 3587, 1058, 32, 68, "Text"],
Cell[CellGroupData[{
Cell[116823, 3623, 112, 3, 29, "Input"],
Cell[116938, 3628, 1014, 24, 120, "Output"]
}, Open  ]],
Cell[117967, 3655, 2319, 79, 125, "Text"],
Cell[120289, 3736, 37, 0, 20, "Text"],
Cell[120329, 3738, 665, 18, 77, "Input",
 InitializationCell->True],
Cell[120997, 3758, 1540, 40, 85, "Text"],
Cell[CellGroupData[{
Cell[122562, 3802, 73, 1, 29, "Input"],
Cell[122638, 3805, 31, 0, 28, "Output"]
}, Open  ]],
Cell[122684, 3808, 213, 5, 35, "Text"]
}, Closed]]
}, Closed]],
Cell[CellGroupData[{
Cell[122946, 3819, 67, 1, 35, "Section",
 CellTags->"Section4"],
Cell[123016, 3822, 191, 4, 35, "Text"],
Cell[CellGroupData[{
Cell[123232, 3830, 88, 2, 32, "Subsection",
 PageBreakWithin->False,
 CellTags->"Section4a"],
Cell[123323, 3834, 309, 7, 35, "Text",
 PageBreakAbove->False,
 PageBreakWithin->False],
Cell[123635, 3843, 762, 17, 82, "Text"],
Cell[124400, 3862, 110, 3, 20, "Text"],
Cell[124513, 3867, 753, 24, 75, "Input",
 InitializationCell->True],
Cell[125269, 3893, 328, 7, 36, "Text"],
Cell[125600, 3902, 138, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[125763, 3909, 117, 3, 29, "Input"],
Cell[125883, 3914, 659, 19, 88, "Output"]
}, Open  ]],
Cell[126557, 3936, 266, 6, 36, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[126860, 3947, 63, 1, 26, "Subsection",
 CellTags->"Section4b"],
Cell[126926, 3950, 570, 20, 35, "Text"],
Cell[127499, 3972, 1183, 36, 92, "Input",
 InitializationCell->True],
Cell[128685, 4010, 374, 7, 36, "Text"],
Cell[CellGroupData[{
Cell[129084, 4021, 117, 3, 29, "Input"],
Cell[129204, 4026, 659, 19, 88, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[129900, 4050, 109, 3, 29, "Input"],
Cell[130012, 4055, 773, 21, 120, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[130834, 4082, 64, 1, 26, "Subsection",
 CellTags->"Section4c"],
Cell[130901, 4085, 478, 9, 50, "Text"],
Cell[CellGroupData[{
Cell[131404, 4098, 54, 0, 18, "Subsubsection"],
Cell[131461, 4100, 628, 14, 51, "Text"],
Cell[CellGroupData[{
Cell[132114, 4118, 82, 2, 28, "Input"],
Cell[132199, 4122, 28, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[132264, 4127, 82, 2, 28, "Input"],
Cell[132349, 4131, 28, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[132414, 4136, 81, 2, 28, "Input"],
Cell[132498, 4140, 28, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[132563, 4145, 81, 2, 28, "Input"],
Cell[132647, 4149, 28, 0, 28, "Output"]
}, Open  ]],
Cell[132690, 4152, 1020, 37, 54, "Text"],
Cell[CellGroupData[{
Cell[133735, 4193, 319, 10, 45, "Input",
 InitializationCell->True],
Cell[134057, 4205, 585, 17, 56, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[134679, 4227, 319, 10, 45, "Input",
 InitializationCell->True],
Cell[135001, 4239, 585, 17, 56, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[135623, 4261, 123, 3, 29, "Input"],
Cell[135749, 4266, 585, 17, 56, "Output"]
}, Open  ]],
Cell[136349, 4286, 362, 12, 35, "Text"],
Cell[136714, 4300, 331, 12, 50, "Equation"],
Cell[137048, 4314, 409, 13, 36, "Text"],
Cell[137460, 4329, 203, 6, 29, "Input",
 InitializationCell->True],
Cell[137666, 4337, 3101, 81, 283, "Input",
 InitializationCell->True],
Cell[140770, 4420, 30, 0, 20, "Text"],
Cell[CellGroupData[{
Cell[140825, 4424, 421, 13, 45, "Input",
 InitializationCell->True],
Cell[141249, 4439, 617, 18, 72, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[141903, 4462, 421, 13, 45, "Input",
 InitializationCell->True],
Cell[142327, 4477, 617, 18, 72, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[142981, 4500, 138, 4, 29, "Input"],
Cell[143122, 4506, 617, 18, 72, "Output"]
}, Open  ]],
Cell[143754, 4527, 521, 14, 53, "Text"],
Cell[144278, 4543, 943, 27, 105, "Input",
 InitializationCell->True],
Cell[145224, 4572, 160, 3, 20, "Text"],
Cell[145387, 4577, 238, 8, 59, "Equation"],
Cell[145628, 4587, 38, 0, 20, "Text"],
Cell[145669, 4589, 264, 9, 59, "Equation"],
Cell[CellGroupData[{
Cell[145958, 4602, 421, 13, 45, "Input",
 InitializationCell->True],
Cell[146382, 4617, 617, 18, 72, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[147036, 4640, 113, 3, 29, "Input"],
Cell[147152, 4645, 617, 18, 72, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[147818, 4669, 62, 0, 17, "Subsubsection"],
Cell[147883, 4671, 157, 3, 20, "Text"],
Cell[148043, 4676, 1920, 50, 183, "Input",
 InitializationCell->True],
Cell[149966, 4728, 105, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[150096, 4735, 101, 2, 29, "Input"],
Cell[150200, 4739, 617, 18, 72, "Output"]
}, Open  ]],
Cell[150832, 4760, 837, 20, 66, "Text"],
Cell[CellGroupData[{
Cell[151694, 4784, 872, 24, 61, "Input",
 InitializationCell->True],
Cell[152569, 4810, 773, 21, 120, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[153379, 4836, 110, 2, 29, "Input"],
Cell[153492, 4840, 818, 23, 44, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[154347, 4868, 122, 3, 29, "Input"],
Cell[154472, 4873, 814, 22, 44, "Output"]
}, Open  ]],
Cell[155301, 4898, 223, 4, 35, "Text"]
}, Open  ]]
}, Closed]]
}, Closed]],
Cell[CellGroupData[{
Cell[155585, 4909, 67, 1, 35, "Section",
 CellTags->"Section5"],
Cell[155655, 4912, 664, 13, 81, "Text"],
Cell[156322, 4927, 300, 5, 35, "Text"],
Cell[156625, 4934, 299, 8, 29, "Input",
 InitializationCell->True],
Cell[156927, 4944, 233, 7, 20, "Text"],
Cell[157163, 4953, 1012, 30, 108, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[158200, 4987, 117, 3, 28, "Input",
 InitializationCell->True],
Cell[158320, 4992, 1292, 44, 44, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[159649, 5041, 71, 1, 29, "Input"],
Cell[159723, 5044, 31, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[159791, 5049, 65, 1, 32, "Subsection",
 CellTags->"Section5a"],
Cell[159859, 5052, 1467, 48, 80, "Text"],
Cell[161329, 5102, 1039, 26, 69, "Text"],
Cell[CellGroupData[{
Cell[162393, 5132, 136, 4, 29, "Input"],
Cell[162532, 5138, 171, 6, 28, "Output"]
}, Open  ]],
Cell[162718, 5147, 478, 10, 51, "Text"],
Cell[CellGroupData[{
Cell[163221, 5161, 169, 5, 29, "Input"],
Cell[163393, 5168, 73, 2, 28, "Output"]
}, Open  ]],
Cell[163481, 5173, 483, 12, 37, "Text"],
Cell[163967, 5187, 504, 15, 61, "Input",
 InitializationCell->True],
Cell[164474, 5204, 265, 9, 20, "Text"],
Cell[CellGroupData[{
Cell[164764, 5217, 129, 3, 29, "Input"],
Cell[164896, 5222, 134, 4, 28, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[165079, 5232, 86, 1, 26, "Subsection",
 CellTags->"Section5b"],
Cell[165168, 5235, 622, 16, 50, "Text"],
Cell[165793, 5253, 988, 32, 52, "Text"],
Cell[CellGroupData[{
Cell[166806, 5289, 131, 4, 29, "Input"],
Cell[166940, 5295, 289, 10, 28, "Output"]
}, Open  ]],
Cell[167244, 5308, 738, 22, 37, "Text"],
Cell[CellGroupData[{
Cell[168007, 5334, 168, 5, 29, "Input"],
Cell[168178, 5341, 2615, 93, 74, "Output"]
}, Open  ]],
Cell[170808, 5437, 361, 10, 21, "Text"],
Cell[CellGroupData[{
Cell[171194, 5451, 59, 1, 28, "Input"],
Cell[171256, 5454, 2973, 113, 269, "Output"]
}, Open  ]],
Cell[174244, 5570, 779, 21, 52, "Text"],
Cell[CellGroupData[{
Cell[175048, 5595, 284, 9, 29, "Input"],
Cell[175335, 5606, 919, 34, 93, "Output"]
}, Open  ]],
Cell[176269, 5643, 236, 5, 36, "Text"],
Cell[176508, 5650, 303, 9, 29, "Input",
 InitializationCell->True],
Cell[176814, 5661, 197, 7, 20, "Text"],
Cell[CellGroupData[{
Cell[177036, 5672, 168, 4, 29, "Input"],
Cell[177207, 5678, 29, 0, 28, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[177285, 5684, 53, 1, 26, "Subsection",
 CellTags->"Section5c"],
Cell[177341, 5687, 222, 6, 20, "Text"],
Cell[177566, 5695, 544, 10, 65, "Text"],
Cell[CellGroupData[{
Cell[178135, 5709, 199, 8, 16, "Item1Numbered"],
Cell[178337, 5719, 466, 15, 29, "Item1Numbered"],
Cell[178806, 5736, 1463, 59, 42, "Item1Numbered"]
}, Open  ]],
Cell[180284, 5798, 293, 10, 37, "Text"],
Cell[180580, 5810, 338, 9, 45, "Input",
 InitializationCell->True],
Cell[180921, 5821, 455, 12, 37, "Text"],
Cell[CellGroupData[{
Cell[181401, 5837, 110, 3, 29, "Input"],
Cell[181514, 5842, 773, 21, 120, "Output"]
}, Open  ]],
Cell[182302, 5866, 306, 5, 35, "Text"],
Cell[CellGroupData[{
Cell[182633, 5875, 187, 5, 29, "Input",
 InitializationCell->True],
Cell[182823, 5882, 2147, 72, 74, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[185007, 5959, 117, 3, 29, "Input"],
Cell[185127, 5964, 2234, 49, 296, "Output"]
}, Open  ]],
Cell[187376, 6016, 330, 6, 51, "Text"]
}, Closed]]
}, Closed]],
Cell[CellGroupData[{
Cell[187755, 6028, 63, 1, 35, "Section",
 CellTags->"Section6"],
Cell[187821, 6031, 367, 8, 50, "Text"],
Cell[CellGroupData[{
Cell[188213, 6043, 73, 1, 32, "Subsection",
 CellTags->"Section6a"],
Cell[188289, 6046, 176, 5, 20, "Text"],
Cell[188468, 6053, 399, 7, 51, "Text"],
Cell[188870, 6062, 304, 8, 29, "Input",
 InitializationCell->True],
Cell[189177, 6072, 387, 9, 37, "Text"],
Cell[CellGroupData[{
Cell[189589, 6085, 69, 1, 29, "Input"],
Cell[189661, 6088, 31, 0, 28, "Output"]
}, Open  ]],
Cell[189707, 6091, 316, 6, 36, "Text"],
Cell[CellGroupData[{
Cell[190048, 6101, 76, 1, 29, "Input"],
Cell[190127, 6104, 31, 0, 28, "Output"]
}, Open  ]],
Cell[190173, 6107, 150, 4, 21, "Text"],
Cell[190326, 6113, 576, 11, 67, "Text"],
Cell[190905, 6126, 204, 5, 29, "Input",
 InitializationCell->True],
Cell[191112, 6133, 218, 6, 21, "Text"],
Cell[CellGroupData[{
Cell[191355, 6143, 68, 1, 28, "Input"],
Cell[191426, 6146, 589, 20, 28, "Output"]
}, Open  ]],
Cell[192030, 6169, 154, 3, 20, "Text"],
Cell[192187, 6174, 1710, 46, 75, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[193922, 6224, 70, 1, 29, "Input"],
Cell[193995, 6227, 31, 0, 28, "Output"]
}, Open  ]],
Cell[194041, 6230, 1868, 50, 75, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[195934, 6284, 70, 1, 29, "Input"],
Cell[196007, 6287, 31, 0, 28, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[196087, 6293, 60, 1, 26, "Subsection",
 CellTags->"Section6b"],
Cell[196150, 6296, 696, 12, 80, "Text"],
Cell[CellGroupData[{
Cell[196871, 6312, 43, 0, 18, "Subsubsection"],
Cell[196917, 6314, 208, 4, 35, "Text"],
Cell[197128, 6320, 1649, 69, 50, "Text"],
Cell[198780, 6391, 349, 9, 35, "Text"],
Cell[199132, 6402, 695, 23, 26, "Equation"],
Cell[199830, 6427, 49, 0, 20, "Text"],
Cell[199882, 6429, 268, 9, 26, "Equation"],
Cell[200153, 6440, 721, 21, 50, "Text"],
Cell[200877, 6463, 345, 7, 35, "Text"],
Cell[201225, 6472, 95, 2, 20, "Text"],
Cell[201323, 6476, 1889, 54, 170, "Input",
 InitializationCell->True],
Cell[203215, 6532, 1034, 34, 65, "Text"],
Cell[204252, 6568, 777, 21, 68, "Text"],
Cell[205032, 6591, 298, 9, 29, "Input",
 InitializationCell->True],
Cell[205333, 6602, 262, 8, 20, "Text"],
Cell[CellGroupData[{
Cell[205620, 6614, 706, 23, 45, "Input"],
Cell[206329, 6639, 230, 8, 28, "Output"]
}, Open  ]],
Cell[206574, 6650, 87, 2, 20, "Text"],
Cell[CellGroupData[{
Cell[206686, 6656, 111, 2, 29, "Input"],
Cell[206800, 6660, 770, 26, 44, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[207619, 6692, 47, 0, 18, "Subsubsection"],
Cell[207669, 6694, 438, 9, 51, "Text"],
Cell[208110, 6705, 816, 23, 52, "Text"],
Cell[208929, 6730, 732, 20, 77, "Input",
 InitializationCell->True],
Cell[209664, 6752, 98, 2, 20, "Text"],
Cell[CellGroupData[{
Cell[209787, 6758, 150, 3, 29, "Input"],
Cell[209940, 6763, 3800, 87, 303, "Output"]
}, Open  ]],
Cell[213755, 6853, 118, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[213898, 6860, 69, 1, 29, "Input"],
Cell[213970, 6863, 1522, 37, 447, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[215529, 6905, 75, 1, 29, "Input"],
Cell[215607, 6908, 2888, 69, 231, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[218532, 6982, 69, 1, 29, "Input"],
Cell[218604, 6985, 1730, 41, 447, "Output"]
}, Open  ]],
Cell[220349, 7029, 883, 19, 82, "Text"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[221281, 7054, 74, 1, 26, "Subsection",
 CellTags->"Section6c"],
Cell[221358, 7057, 126, 3, 20, "Text"],
Cell[221487, 7062, 610, 20, 35, "Text"],
Cell[222100, 7084, 1286, 35, 153, "Input",
 InitializationCell->True],
Cell[223389, 7121, 256, 7, 36, "Text"],
Cell[CellGroupData[{
Cell[223670, 7132, 68, 1, 29, "Input"],
Cell[223741, 7135, 1476, 37, 375, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[225254, 7177, 127, 3, 29, "Input"],
Cell[225384, 7182, 50, 1, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[225471, 7188, 152, 4, 29, "Input"],
Cell[225626, 7194, 83, 2, 28, "Output"]
}, Open  ]],
Cell[225724, 7199, 127, 3, 20, "Text"],
Cell[225854, 7204, 298, 9, 29, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[226177, 7217, 127, 3, 29, "Input"],
Cell[226307, 7222, 83, 2, 28, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[226439, 7230, 63, 1, 26, "Subsection",
 CellTags->"Section6d"],
Cell[226505, 7233, 348, 8, 36, "Text"],
Cell[226856, 7243, 308, 6, 36, "Text"],
Cell[227167, 7251, 932, 26, 120, "Input",
 InitializationCell->True],
Cell[228102, 7279, 373, 14, 21, "Text"],
Cell[CellGroupData[{
Cell[228500, 7297, 159, 4, 29, "Input"],
Cell[228662, 7303, 31, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[228730, 7308, 172, 5, 29, "Input"],
Cell[228905, 7315, 32, 0, 28, "Output"]
}, Open  ]],
Cell[228952, 7318, 283, 6, 36, "Text"],
Cell[229238, 7326, 922, 26, 107, "Input",
 InitializationCell->True],
Cell[230163, 7354, 222, 9, 21, "Text"],
Cell[CellGroupData[{
Cell[230410, 7367, 139, 4, 29, "Input"],
Cell[230552, 7373, 83, 2, 28, "Output"]
}, Open  ]],
Cell[230650, 7378, 489, 10, 67, "Text"],
Cell[231142, 7390, 840, 24, 93, "Input",
 InitializationCell->True],
Cell[231985, 7416, 529, 19, 36, "Text"],
Cell[CellGroupData[{
Cell[232539, 7439, 143, 4, 29, "Input"],
Cell[232685, 7445, 28, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[232750, 7450, 153, 4, 29, "Input"],
Cell[232906, 7456, 28, 0, 28, "Output"]
}, Open  ]],
Cell[232949, 7459, 143, 4, 29, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[233129, 7468, 54, 1, 26, "Subsection",
 CellTags->"Section6e"],
Cell[233186, 7471, 392, 7, 51, "Text"],
Cell[233581, 7480, 395, 6, 50, "Text"],
Cell[233979, 7488, 243, 7, 29, "Input",
 InitializationCell->True],
Cell[234225, 7497, 760, 18, 85, "Text"],
Cell[234988, 7517, 225, 6, 29, "Input",
 InitializationCell->True],
Cell[235216, 7525, 512, 19, 36, "Text"],
Cell[235731, 7546, 1176, 33, 137, "Input",
 InitializationCell->True],
Cell[236910, 7581, 350, 9, 37, "Text"],
Cell[CellGroupData[{
Cell[237285, 7594, 104, 2, 28, "Input"],
Cell[237392, 7598, 32, 0, 28, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[237461, 7603, 103, 2, 28, "Input"],
Cell[237567, 7607, 31, 0, 28, "Output"]
}, Open  ]]
}, Closed]]
}, Closed]],
Cell[CellGroupData[{
Cell[237659, 7614, 115, 3, 35, "Section",
 CellTags->"Solutions"],
Cell[CellGroupData[{
Cell[237799, 7621, 70, 1, 32, "Subsection",
 CellTags->"SolutionsCP15"],
Cell[237872, 7624, 138, 3, 42, "Problem"],
Cell[238013, 7629, 197, 5, 20, "Text"],
Cell[238213, 7636, 622, 18, 51, "Text"],
Cell[238838, 7656, 1228, 32, 168, "Input",
 InitializationCell->True],
Cell[240069, 7690, 93, 4, 21, "Text"],
Cell[CellGroupData[{
Cell[240187, 7698, 72, 1, 29, "Input"],
Cell[240262, 7701, 183, 3, 28, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[240494, 7710, 80, 1, 26, "Subsection",
 CellTags->"SolutionsCE1"],
Cell[240577, 7713, 91, 2, 42, "Problem"],
Cell[240671, 7717, 813, 23, 51, "Text"],
Cell[241487, 7742, 214, 6, 29, "Input",
 InitializationCell->True],
Cell[241704, 7750, 291, 7, 36, "Text"],
Cell[CellGroupData[{
Cell[242020, 7761, 143, 4, 28, "Input"],
Cell[242166, 7767, 2973, 113, 269, "Output"]
}, Open  ]],
Cell[245154, 7883, 391, 12, 42, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[245582, 7900, 80, 1, 26, "Subsection",
 CellTags->"SolutionsCE4"],
Cell[245665, 7903, 341, 12, 42, "Problem"],
Cell[246009, 7917, 290, 9, 35, "Text"],
Cell[CellGroupData[{
Cell[246324, 7930, 854, 25, 55, "Item1Numbered"],
Cell[247181, 7957, 794, 26, 52, "Item1Numbered"],
Cell[247978, 7985, 345, 7, 43, "Item1Numbered"]
}, Open  ]],
Cell[248338, 7995, 49, 0, 20, "Text"],
Cell[248390, 7997, 1257, 33, 137, "Input",
 InitializationCell->True],
Cell[249650, 8032, 119, 3, 20, "Text"],
Cell[CellGroupData[{
Cell[249794, 8039, 68, 1, 28, "Input"],
Cell[249865, 8042, 30, 0, 28, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[249944, 8048, 80, 1, 26, "Subsection",
 CellTags->"SolutionsCE5"],
Cell[250027, 8051, 276, 5, 55, "Problem"],
Cell[250306, 8058, 399, 10, 35, "Text"],
Cell[250708, 8070, 1208, 28, 84, "Text"],
Cell[CellGroupData[{
Cell[251941, 8102, 349, 9, 44, "Input",
 InitializationCell->True],
Cell[252293, 8113, 927, 23, 152, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[253257, 8141, 108, 3, 28, "Input"],
Cell[253368, 8146, 927, 23, 152, "Output"]
}, Open  ]]
}, Closed]]
}, Closed]],
Cell[CellGroupData[{
Cell[254356, 8176, 52, 1, 35, "Section",
 CellTags->"Exercises"],
Cell[CellGroupData[{
Cell[254433, 8181, 342, 9, 35, "Item1Exercise"],
Cell[254778, 8192, 130, 5, 20, "Item1Exercise"]
}, Open  ]],
Cell[254923, 8200, 155, 4, 29, "myCode"],
Cell[255081, 8206, 1221, 43, 44, "ExerciseContinuation"],
Cell[256305, 8251, 120, 4, 28, "myCode"],
Cell[CellGroupData[{
Cell[256450, 8259, 176, 5, 20, "Item1Exercise"],
Cell[256629, 8266, 257, 4, 33, "Item1Exercise"],
Cell[256889, 8272, 232, 6, 33, "Item1Exercise"],
Cell[257124, 8280, 251, 4, 33, "Item1Exercise"],
Cell[257378, 8286, 990, 31, 46, "Item1Exercise"],
Cell[258371, 8319, 246, 6, 33, "Item1Exercise"],
Cell[258620, 8327, 593, 18, 46, "Item1Exercise"],
Cell[259216, 8347, 171, 5, 20, "Item1Exercise"],
Cell[259390, 8354, 263, 7, 33, "Item1Exercise"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)
